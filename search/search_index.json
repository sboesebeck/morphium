{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Morphium v6 Documentation","text":"<p>Morphium is a Java 21+ Object Document Mapper (ODM) and MongoDB\u2011backed messaging system. It includes a custom MongoDB wire\u2011protocol driver, distributed caching, and a topic\u2011based message queue.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Start here: Overview of features and a short quick start.</li> <li>Setup: Developer Guide for mapping, queries, aggregation, caching, configuration, and extension points.</li> <li>Messaging: dedicated Messaging guide (exclusive vs broadcast, listeners, concurrency, change streams).</li> <li>How\u2011Tos: focused recipes for common tasks and migrations \u2014 browse How\u2011Tos to get started.</li> </ul>"},{"location":"#testing-development","title":"Testing &amp; Development","text":"<p>Morphium includes a complete in-memory MongoDB-compatible implementation for testing and development: - InMemory Driver - Embedded in-memory driver for unit tests (no MongoDB installation required!) - MorphiumServer - Standalone MongoDB-compatible server that speaks the wire protocol   - Perfect for CI/CD pipelines, integration testing, and microservices development   - Any MongoDB client (Java, Python, Node.js, Go, etc.) can connect to it   - Run with: <code>java -cp morphium.jar de.caluga.morphium.server.MorphiumServer --port 27017</code></p>"},{"location":"#production-deployment","title":"Production Deployment","text":"<ul> <li>Production Deployment Guide - Complete guide for deploying Morphium in production environments</li> <li>Configuration Reference - Complete reference for all configuration options</li> <li>Performance &amp; Scalability Guide - Optimization strategies from small to large scale</li> <li>Security Guide - Security considerations for MongoDB Community Edition deployments</li> </ul>"},{"location":"#operations-monitoring","title":"Operations &amp; Monitoring","text":"<ul> <li>Monitoring &amp; Metrics Guide - Comprehensive monitoring with DriverStats and performance metrics</li> <li>Troubleshooting Guide - Common issues, diagnosis, and solutions</li> <li>Architecture Overview - Internal architecture and component relationships</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>API Reference - Complete API documentation with examples</li> </ul> <p>Minimum requirements - Java 21+ - MongoDB 5.0+</p> <p>Links - Repository: https://github.com/sboesebeck/morphium</p>"},{"location":"#motivation-history","title":"Motivation &amp; History","text":"<p>Morphium started when there was no official MongoDB object mapper and the then\u2011popular Morphia lacked extensibility around caching. We set out to build a flexible, extensible ODM with declarative features\u2014especially for caching. At that time, Jackson also missed a few capabilities we needed (like better generics handling), so Morphium ships its own object mapper tuned precisely for Morphium\u2019s use cases and performance.</p> <p>The initial Message Queuing feature was created to synchronize caches across a cluster; it has since evolved into a production\u2011ready messaging system.</p> <p>Learn more - Object mapping and configuration: see the Developer Guide - Caching: see Caching Examples and Cache Patterns - Messaging: see Messaging - Testing without MongoDB: see InMemory Driver, MorphiumServer, and Migration v5 \u2192 v6</p>"},{"location":"#our-own-driver-since-50","title":"Our own driver (since 5.0)","text":"<p>With Morphium 5.0 we implemented our own MongoDB driver. The official driver includes object mapping, which interfered with Morphium\u2019s mapping system, and we also experienced some failover issues. Building our own wire\u2011protocol driver gave us full control over mapping, retry/failover behavior, and performance characteristics.</p> <p>Benefits - Tailored to Morphium\u2019s mapping and lifecycle needs; minimal impedance with Morphium\u2019s object mapper. - Full control over retry/failover semantics and performance trade\u2011offs.</p> <p>Limitations - No MongoDB Atlas support (Atlas requires features like mandatory TLS that are not supported here). - No SSL/TLS\u2011encrypted connections; use plain connections or terminate TLS outside MongoDB. (Some community distributions may not include SSL/TLS.) - Some advanced features of the official driver are not available.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Comprehensive reference for Morphium's core APIs, methods, and interfaces.</p>"},{"location":"api-reference/#core-morphium-api","title":"Core Morphium API","text":""},{"location":"api-reference/#morphium-class","title":"Morphium Class","text":"<p>The main entry point for all Morphium operations.</p>"},{"location":"api-reference/#constructor","title":"Constructor","text":"<pre><code>// Primary constructor\npublic Morphium(MorphiumConfig config)\n\n// Convenience constructors (since V2.2.23)\npublic Morphium(String host, String database)\npublic Morphium(String host, int port, String database) \n</code></pre>"},{"location":"api-reference/#basic-operations","title":"Basic Operations","text":"<p>Store Operations: <pre><code>// Store single entity\npublic &lt;T&gt; void store(T entity)\npublic &lt;T&gt; void store(T entity, AsyncOperationCallback&lt;T&gt; callback)\n\n// Store multiple entities\npublic &lt;T&gt; void storeList(List&lt;T&gt; entities)\npublic &lt;T&gt; void storeList(List&lt;T&gt; entities, AsyncOperationCallback&lt;T&gt; callback)\n\n// Update using fields (partial updates)\npublic &lt;T&gt; void updateUsingFields(T entity, String... fields)\n</code></pre></p> <p>Delete Operations: <pre><code>// Delete single entity\npublic &lt;T&gt; void delete(T entity)\npublic &lt;T&gt; void delete(T entity, AsyncOperationCallback&lt;T&gt; callback)\n\n// Delete by query\npublic &lt;T&gt; void delete(Query&lt;T&gt; query)\npublic &lt;T&gt; void delete(Query&lt;T&gt; query, AsyncOperationCallback&lt;T&gt; callback)\n</code></pre></p> <p>Query Operations: <pre><code>// Create query for type\npublic &lt;T&gt; Query&lt;T&gt; createQueryFor(Class&lt;T&gt; type)\n\n// Get single entity by ID\npublic &lt;T&gt; T findById(Class&lt;T&gt; type, Object id)\n</code></pre></p>"},{"location":"api-reference/#configuration-and-lifecycle","title":"Configuration and Lifecycle","text":"<pre><code>// Get configuration\npublic MorphiumConfig getConfig()\n\n// Get driver\npublic MorphiumDriver getDriver()\n\n// Close connection and cleanup\npublic void close()\n\n// Check if closed\npublic boolean isClosed()\n</code></pre>"},{"location":"api-reference/#index-management","title":"Index Management","text":"<pre><code>// Ensure all indexes for a type\npublic &lt;T&gt; void ensureIndicesFor(Class&lt;T&gt; type)\n\n// Create index manually\npublic &lt;T&gt; void ensureIndex(Class&lt;T&gt; type, Map&lt;String, Object&gt; index)\npublic &lt;T&gt; void ensureIndex(Class&lt;T&gt; type, String... fields)\n</code></pre>"},{"location":"api-reference/#transaction-support","title":"Transaction Support","text":"<pre><code>// Transaction management\npublic void beginTransaction()\npublic void commitTransaction() \npublic void abortTransaction()\n\n// Check transaction state\npublic boolean isTransactionInProgress()\npublic MorphiumTransactionContext getTransactionContext()\n</code></pre>"},{"location":"api-reference/#query-api","title":"Query API","text":""},{"location":"api-reference/#query-interface","title":"Query Interface","text":"<p>Field Selection: <pre><code>// Select field for operations\npublic Query&lt;T&gt; f(String field)\npublic Query&lt;T&gt; f(Enum field) // Using field enums\n\n// Field operations\npublic Query&lt;T&gt; eq(Object value)           // Equal\npublic Query&lt;T&gt; ne(Object value)           // Not equal  \npublic Query&lt;T&gt; lt(Object value)           // Less than\npublic Query&lt;T&gt; lte(Object value)          // Less than or equal\npublic Query&lt;T&gt; gt(Object value)           // Greater than\npublic Query&lt;T&gt; gte(Object value)          // Greater than or equal\npublic Query&lt;T&gt; in(Collection&lt;?&gt; values)   // In array\npublic Query&lt;T&gt; nin(Collection&lt;?&gt; values)  // Not in array\npublic Query&lt;T&gt; matches(String regex)      // Regex match\npublic Query&lt;T&gt; exists()                   // Field exists\npublic Query&lt;T&gt; notExists()               // Field doesn't exist\n</code></pre></p> <p>Query Modifiers: <pre><code>// Sorting\npublic Query&lt;T&gt; sort(String field)        // Ascending\npublic Query&lt;T&gt; sort(Map&lt;String, Integer&gt; sort) // Custom sort\n\n// Pagination\npublic Query&lt;T&gt; skip(int skip)\npublic Query&lt;T&gt; limit(int limit)\n\n// Projection  \npublic Query&lt;T&gt; project(String... fields)\npublic Query&lt;T&gt; addProjection(String field, String projection)\n</code></pre></p> <p>Query Execution: <pre><code>// Get results\npublic List&lt;T&gt; asList()                    // All results as list\npublic T get()                             // Single result (first match)\npublic long countAll()                     // Count all matches\n\n// Async execution\npublic void asList(AsyncOperationCallback&lt;T&gt; callback)\npublic void get(AsyncOperationCallback&lt;T&gt; callback)\n\n// Iterator for large result sets\npublic MorphiumIterator&lt;T&gt; asIterable()\npublic MorphiumIterator&lt;T&gt; asIterable(int windowSize)\npublic MorphiumIterator&lt;T&gt; asIterable(int windowSize, int prefetch)\n</code></pre></p> <p>Logical Operators: <pre><code>// OR conditions\npublic Query&lt;T&gt; or(Query&lt;T&gt;... queries)\n\n// NOR conditions  \npublic Query&lt;T&gt; nor(Query&lt;T&gt;... queries)\n\n// Create sub-query\npublic Query&lt;T&gt; q() // New query instance\n</code></pre></p> <p>Advanced Features: <pre><code>// Text search\npublic Query&lt;T&gt; text(Query.TextSearchLanguages language, String... terms)\npublic Query&lt;T&gt; text(Query.TextSearchLanguages language, boolean caseSensitive, \n                     boolean diacriticSensitive, String... terms)\n\n// Distinct values\npublic List&lt;Object&gt; distinct(String field)\n\n// Complex query with raw MongoDB query\npublic List&lt;T&gt; complexQuery(Map&lt;String, Object&gt; query)\n</code></pre></p>"},{"location":"api-reference/#aggregation-api","title":"Aggregation API","text":""},{"location":"api-reference/#aggregator-interface","title":"Aggregator Interface","text":"<pre><code>// Create aggregator\npublic &lt;T, R&gt; Aggregator&lt;T, R&gt; createAggregator(Class&lt;T&gt; inputType, Class&lt;R&gt; resultType)\n</code></pre> <p>Pipeline Operations: <pre><code>// Match stage (filter)\npublic Aggregator&lt;T, R&gt; match(Query&lt;T&gt; query)\n\n// Project stage (field selection/transformation)  \npublic Aggregator&lt;T, R&gt; project(String... fields)\npublic Aggregator&lt;T, R&gt; project(Map&lt;String, Object&gt; projection)\n\n// Group stage\npublic Aggregator&lt;T, R&gt; group(String groupBy)\npublic Aggregator&lt;T, R&gt; group(Map&lt;String, Object&gt; groupBy)\n\n// Group operations\npublic Aggregator&lt;T, R&gt; sum(String field, String source)\npublic Aggregator&lt;T, R&gt; avg(String field, String source)  \npublic Aggregator&lt;T, R&gt; min(String field, String source)\npublic Aggregator&lt;T, R&gt; max(String field, String source)\npublic Aggregator&lt;T, R&gt; first(String field, String source)\npublic Aggregator&lt;T, R&gt; last(String field, String source)\npublic Aggregator&lt;T, R&gt; count(String field)\n\n// End group stage\npublic Aggregator&lt;T, R&gt; end()\n\n// Sort stage\npublic Aggregator&lt;T, R&gt; sort(String... fields)\npublic Aggregator&lt;T, R&gt; sort(Map&lt;String, Integer&gt; sort)\n\n// Skip/Limit stages\npublic Aggregator&lt;T, R&gt; skip(int skip)\npublic Aggregator&lt;T, R&gt; limit(int limit)\n</code></pre></p> <p>Execution: <pre><code>// Execute aggregation\npublic List&lt;R&gt; aggregate()\n\n// Get raw aggregation list\npublic List&lt;Map&lt;String, Object&gt;&gt; toAggregationList()\n</code></pre></p>"},{"location":"api-reference/#messaging-api","title":"Messaging API","text":""},{"location":"api-reference/#messaging-interface","title":"Messaging Interface","text":"<p>Setup and Lifecycle: <pre><code>// Initialize messaging\npublic void init(Morphium morphium)\npublic void init(Morphium morphium, MessagingSettings settings)\n\n// Start/stop messaging\npublic void start()\npublic void terminate()\n\n// Check state\npublic boolean isAlive()\n</code></pre></p> <p>Message Operations: <pre><code>// Send message\npublic void sendMessage(Msg message)\n\n// Send and wait for responses\npublic Msg sendAndAwaitFirstAnswer(Msg message, long timeout)\npublic List&lt;Msg&gt; sendAndAwaitAnswers(Msg message, int expectedAnswers, long timeout)\n\n// Send message to specific listener\npublic void sendDirectMessage(Msg message, String host, String listenerId)\n</code></pre></p> <p>Listener Management: <pre><code>// Add topic listener\npublic void addListenerForTopic(String topic, MessageListener listener)\npublic void addListenerForTopic(String topic, MessageListener listener, boolean multithreaded)\n\n// Remove listener\npublic boolean removeListenerForTopic(String topic, MessageListener listener)\n\n// Get registered listeners\npublic List&lt;MessageListener&gt; getListenersForTopic(String topic)\n</code></pre></p> <p>Message Listener Interface: <pre><code>@FunctionalInterface\npublic interface MessageListener {\n    /**\n     * Process incoming message\n     * @param messaging The messaging instance\n     * @param message The received message\n     * @return Response message (null if no response)\n     */\n    Msg onMessage(Morphium messaging, Msg message);\n}\n</code></pre></p>"},{"location":"api-reference/#msg-class","title":"Msg Class","text":"<p>Constructor: <pre><code>public Msg(String topic, String message, String value)\npublic Msg(String topic, String message, String value, long ttl)\n</code></pre></p> <p>Properties: <pre><code>// Basic properties\npublic String getTopic()\npublic void setTopic(String topic)\n\npublic String getMsg()\npublic void setMsg(String message) \n\npublic String getValue()\npublic void setValue(String value)\n\n// Timing properties\npublic long getTtl()\npublic void setTtl(long ttl)\n\npublic long getTimestamp()\npublic void setTimestamp(long timestamp)\n\n// Message routing\npublic boolean isExclusive()\npublic void setExclusive(boolean exclusive)\n\npublic String getInAnswerTo()  \npublic void setInAnswerTo(String inAnswerTo)\n\npublic String getSender()\npublic void setSender(String sender)\n\npublic String getRecipient()\npublic void setRecipient(String recipient)\n</code></pre></p> <p>Map Values (for complex data): <pre><code>// Store/retrieve complex objects as map\npublic Map&lt;String, Object&gt; getMapValue()\npublic void setMapValue(Map&lt;String, Object&gt; mapValue)\n\n// Convenience methods\npublic void addAdditional(String key, Object value)\npublic Object getAdditional(String key)\n</code></pre></p>"},{"location":"api-reference/#configuration-api","title":"Configuration API","text":""},{"location":"api-reference/#morphiumconfig","title":"MorphiumConfig","text":"<p>Main Settings Access: <pre><code>// Get nested settings objects\npublic ConnectionSettings connectionSettings()\npublic ClusterSettings clusterSettings()\npublic DriverSettings driverSettings()\npublic MessagingSettings messagingSettings()\npublic CacheSettings cacheSettings()\npublic ThreadPoolSettings threadPoolSettings()\npublic WriterSettings writerSettings()\npublic ObjectMappingSettings objectMappingSettings()\npublic EncryptionSettings encryptionSettings()\npublic CollectionCheckSettings collectionCheckSettings()\npublic AuthSettings authSettings()\n</code></pre></p> <p>Logging Configuration:</p> <p>Logging in Morphium is handled by Log4j2. Configure logging in your <code>log4j2.xml</code> file:</p> <pre><code>&lt;!-- Example log4j2.xml configuration --&gt;\n&lt;Configuration&gt;\n    &lt;Appenders&gt;\n        &lt;Console name=\"Console\"&gt;\n            &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt;\n        &lt;/Console&gt;\n        &lt;File name=\"MorphiumLog\" fileName=\"/var/log/morphium/app.log\"&gt;\n            &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt;\n        &lt;/File&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;!-- All Morphium components --&gt;\n        &lt;Logger name=\"de.caluga.morphium\" level=\"INFO\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"Console\"/&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;!-- Driver-specific logging --&gt;\n        &lt;Logger name=\"de.caluga.morphium.driver\" level=\"DEBUG\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <p>Factory Methods: <pre><code>// Create from different sources\npublic static MorphiumConfig createFromJson(String json)\npublic static MorphiumConfig fromProperties(Properties props)\n</code></pre></p>"},{"location":"api-reference/#annotation-reference","title":"Annotation Reference","text":""},{"location":"api-reference/#entity-annotations","title":"Entity Annotations","text":"<p>@Entity <pre><code>@Entity(\n    value = \"collection_name\",        // Custom collection name\n    translateCamelCase = true,        // Convert camelCase to snake_case\n    polymorph = false,                // Store class name for inheritance\n    useFQN = false,                   // Use fully qualified class name\n    nameProvider = NameProvider.class // Custom naming strategy\n)\n</code></pre></p> <p>@Embedded <pre><code>@Embedded(\n    polymorph = false,     // Store class name for polymorphism\n    translateCamelCase = true // Convert field names\n)\n</code></pre></p> <p>@Id <pre><code>@Id // Mark field as MongoDB _id field\n</code></pre></p> <p>@Property <pre><code>@Property(\n    fieldName = \"custom_field_name\"  // Custom field name in MongoDB\n)\n</code></pre></p> <p>@Reference <pre><code>@Reference(\n    lazyLoading = false,    // Enable lazy loading\n    fieldName = \"ref_field\" // Custom field name\n)\n</code></pre></p>"},{"location":"api-reference/#index-annotations","title":"Index Annotations","text":"<p>@Index (Field Level) <pre><code>@Index(\n    direction = IndexDirection.ASC,  // ASC or DESC\n    options = {\"unique:true\"}        // MongoDB index options\n)\n</code></pre></p> <p>@Index (Class Level) <pre><code>@Index({\n    \"field1\",           // Simple ascending index\n    \"-field2\",          // Descending index (note the minus)\n    \"field3,field4\",    // Compound index\n    \"location:2d\"       // Geospatial index\n})\n</code></pre></p>"},{"location":"api-reference/#caching-annotations","title":"Caching Annotations","text":"<p>@Cache <pre><code>@Cache(\n    timeout = 60000,                    // Cache timeout in ms\n    maxEntries = 10000,                 // Maximum cache entries\n    strategy = Cache.ClearStrategy.LRU, // Eviction strategy\n    syncCache = Cache.SyncCacheStrategy.CLEAR_TYPE_CACHE, // Cluster sync\n    clearOnWrite = true                 // Clear cache on writes\n)\n</code></pre></p> <p>@NoCache <pre><code>@NoCache // Disable caching for this entity\n</code></pre></p>"},{"location":"api-reference/#write-buffer-annotations","title":"Write Buffer Annotations","text":"<p>@WriteBuffer <pre><code>@WriteBuffer(\n    size = 1000,                              // Buffer size\n    timeout = 5000,                           // Flush timeout (ms)\n    strategy = WriteBuffer.STRATEGY.WRITE_OLD // Strategy when full\n)\n</code></pre></p> <p>@AsyncWrites <pre><code>@AsyncWrites // All writes are asynchronous\n</code></pre></p>"},{"location":"api-reference/#lifecycle-annotations","title":"Lifecycle Annotations","text":"<p>@CreationTime <pre><code>@CreationTime\nprivate long createdAt; // Set on first save\n</code></pre></p> <p>@LastChange <pre><code>@LastChange  \nprivate long lastModified; // Updated on each save\n</code></pre></p> <p>@LastAccess <pre><code>@LastAccess\nprivate long lastAccessed; // Updated on each read\n</code></pre></p> <p>Lifecycle Callbacks: <pre><code>@PreStore\npublic void beforeStore() {\n    // Called before storing to database\n}\n\n@PostStore  \npublic void afterStore() {\n    // Called after successful store\n}\n\n@PreLoad\npublic void beforeLoad() {\n    // Called before loading from database\n}\n\n@PostLoad\npublic void afterLoad() {\n    // Called after loading from database\n}\n</code></pre></p>"},{"location":"api-reference/#validation-annotations","title":"Validation Annotations","text":"<p>Morphium supports standard javax.validation annotations:</p> <pre><code>@Entity\npublic class User {\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @Email\n    private String email;\n\n    @Min(18)\n    private int age;\n\n    @Pattern(regexp = \"^[A-Za-z]+$\")\n    private String firstName;\n}\n</code></pre>"},{"location":"api-reference/#exception-handling","title":"Exception Handling","text":""},{"location":"api-reference/#common-exceptions","title":"Common Exceptions","text":"<p>MorphiumDriverException: <pre><code>// Thrown for driver-level issues\ntry {\n    morphium.store(entity);\n} catch (MorphiumDriverException e) {\n    // Handle connection/driver errors\n    logger.error(\"Driver error: \" + e.getMessage(), e);\n}\n</code></pre></p> <p>MorphiumAccessVetoException: <pre><code>// Thrown when access is denied by security rules\ntry {\n    List&lt;User&gt; users = query.asList();\n} catch (MorphiumAccessVetoException e) {\n    // Handle security violations\n    logger.warn(\"Access denied: \" + e.getMessage());\n}\n</code></pre></p>"},{"location":"api-reference/#utility-classes","title":"Utility Classes","text":""},{"location":"api-reference/#morphiumiterator","title":"MorphiumIterator","text":"<p>Large Dataset Processing: <pre><code>// Create iterator\nMorphiumIterator&lt;Entity&gt; iterator = query.asIterable(1000, 5);\n\n// Navigation\npublic boolean hasNext()\npublic T next()\npublic void remove()\n\n// Position information  \npublic long getCount()         // Total number of results\npublic int getCursor()         // Current position\npublic void ahead(int steps)   // Jump ahead\npublic void back(int steps)    // Jump back\n\n// Buffer information\npublic List&lt;T&gt; getCurrentBuffer()     // Current buffer contents\npublic int getCurrentBufferSize()     // Current buffer size\n\n// Threading\npublic void setMultithreaddedAccess(boolean enable)\n</code></pre></p>"},{"location":"api-reference/#objectmapper","title":"ObjectMapper","text":"<p>Manual Object Mapping: <pre><code>ObjectMapper mapper = morphium.getMapper();\n\n// Object to BSON\nMap&lt;String, Object&gt; bson = mapper.marshall(entity);\n\n// BSON to Object  \nEntity entity = mapper.unmarshall(Entity.class, bson);\n\n// JSON support\nString json = mapper.marshall(entity).toString();\nEntity entity = mapper.unmarshall(Entity.class, json);\n</code></pre></p> <p>This API reference provides comprehensive documentation of all major Morphium APIs, including method signatures, parameters, and usage examples.</p>"},{"location":"architecture-overview/","title":"Architecture Overview","text":"<p>Understanding Morphium's internal architecture and component relationships.</p>"},{"location":"architecture-overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Application   \u2502    \u2502    Messaging    \u2502    \u2502      Cache      \u2502\n\u2502                 \u2502    \u2502    System       \u2502    \u2502   Management    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                      \u2502                      \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502           Morphium Core             \u2502\n              \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n              \u2502  \u2502   Query     \u2502 \u2502   Object    \u2502    \u2502\n              \u2502  \u2502   System    \u2502 \u2502   Mapper    \u2502    \u2502\n              \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502         Driver Layer               \u2502\n              \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n              \u2502  \u2502  Pooled     \u2502 \u2502  Single     \u2502    \u2502\n              \u2502  \u2502  Driver     \u2502 \u2502  Driver     \u2502    \u2502\n              \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502         Wire Protocol              \u2502\n              \u2502    MongoDB Communication Layer      \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502            MongoDB                 \u2502\n              \u2502      (Replica Set / Cluster)       \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture-overview/#core-components","title":"Core Components","text":""},{"location":"architecture-overview/#1-morphium-core-morphiumjava","title":"1. Morphium Core (<code>Morphium.java</code>)","text":"<p>Central facade providing all database operations and configuration.</p> <p>Key Responsibilities: - Configuration management - Driver lifecycle - Transaction coordination - Entity lifecycle management</p> <p>Main APIs: <pre><code>// CRUD operations\nmorphium.store(entity);\nmorphium.delete(entity);\nQuery&lt;T&gt; query = morphium.createQueryFor(Class.class);\n\n// Transaction support\nmorphium.beginTransaction();\nmorphium.commitTransaction();\nmorphium.abortTransaction();\n\n// Configuration access\nMorphiumConfig config = morphium.getConfig();\n</code></pre></p>"},{"location":"architecture-overview/#2-driver-architecture","title":"2. Driver Architecture","text":"<p>Three driver implementations for different use cases:</p>"},{"location":"architecture-overview/#pooleddriver-default-production","title":"PooledDriver (Default - Production)","text":"<ul> <li>Connection pooling with configurable min/max connections per host</li> <li>Replica set support with automatic failover</li> <li>Health monitoring with heartbeat checks</li> <li>Load balancing across replica set members</li> </ul> <pre><code>// Internal architecture\nPooledDriver {\n    Map&lt;String, BlockingQueue&lt;Connection&gt;&gt; connectionPool;\n    Map&lt;Integer, Connection&gt; borrowedConnections;\n    Map&lt;String, AtomicInteger&gt; waitCounter;\n    ScheduledExecutorService heartbeat;\n}\n</code></pre>"},{"location":"architecture-overview/#singlemongoconnectdriver","title":"SingleMongoConnectDriver","text":"<ul> <li>Single connection per operation</li> <li>Simpler implementation for low-concurrency scenarios</li> <li>No connection pooling overhead</li> </ul>"},{"location":"architecture-overview/#inmemorydriver-testing","title":"InMemoryDriver (Testing)","text":"<ul> <li>Full in-memory MongoDB emulation</li> <li>No network communication</li> <li>Supports most MongoDB operations including aggregation</li> <li>Perfect for unit testing</li> </ul>"},{"location":"architecture-overview/#3-object-mapping-system","title":"3. Object Mapping System","text":""},{"location":"architecture-overview/#objectmapperimpl","title":"ObjectMapperImpl","text":"<p>Bidirectional mapping between Java objects and BSON documents.</p> <p>Features: - Annotation-driven mapping (<code>@Entity</code>, <code>@Embedded</code>, <code>@Property</code>) - Type conversion for Java \u2192 BSON \u2192 Java - Reference resolution (lazy and eager) - Polymorphism support with class name storage</p> <p>Mapping Flow: <pre><code>Java Object \u2192 ObjectMapper \u2192 BSON Document \u2192 MongoDB\nMongoDB \u2192 BSON Document \u2192 ObjectMapper \u2192 Java Object\n</code></pre></p>"},{"location":"architecture-overview/#type-mappers","title":"Type Mappers","text":"<p>Specialized mappers for different Java types: - <code>BigDecimalTypeMapper</code> - <code>BigIntegerTypeMapper</code> - <code>DateTypeMapper</code> - <code>EnumTypeMapper</code> - Collections and arrays</p>"},{"location":"architecture-overview/#4-query-system","title":"4. Query System","text":""},{"location":"architecture-overview/#query-interface","title":"Query Interface","text":"<p>Fluent API for building MongoDB queries:</p> <pre><code>Query&lt;User&gt; q = morphium.createQueryFor(User.class)\n    .f(\"status\").eq(\"active\")\n    .f(\"age\").gte(18)\n    .sort(\"-created\")\n    .limit(100);\n</code></pre>"},{"location":"architecture-overview/#morphiumiterator","title":"MorphiumIterator","text":"<p>Paged iteration for large result sets: - Configurable window size - Prefetching support - Thread-safe access - Memory-efficient processing</p>"},{"location":"architecture-overview/#aggregation-framework","title":"Aggregation Framework","text":"<p>MongoDB aggregation pipeline support: <pre><code>Aggregator&lt;Order, OrderStats&gt; agg = morphium.createAggregator(Order.class, OrderStats.class)\n    .match(morphium.createQueryFor(Order.class).f(\"status\").eq(\"completed\"))\n    .group(\"customerId\").sum(\"total\", \"$amount\").avg(\"avgAmount\", \"$amount\").end()\n    .sort(\"total\");\n</code></pre></p>"},{"location":"architecture-overview/#5-caching-system","title":"5. Caching System","text":""},{"location":"architecture-overview/#multi-level-caching","title":"Multi-Level Caching","text":"<ol> <li>Query Result Cache - Caches query results</li> <li>ID Cache - Caches individual entities by ID  </li> <li>Write Cache - Buffers writes for performance</li> </ol>"},{"location":"architecture-overview/#cache-synchronization","title":"Cache Synchronization","text":"<p>Cluster-aware caching with synchronization: - WatchingCacheSynchronizer - Uses MongoDB Change Streams - MessagingCacheSynchronizer - Uses Morphium messaging - Manual cache control for custom strategies</p>"},{"location":"architecture-overview/#cache-strategies","title":"Cache Strategies","text":"<pre><code>@Cache(\n    timeout = 60000,           // 60-second TTL\n    maxEntries = 10000,        // LRU eviction limit\n    strategy = Cache.ClearStrategy.LRU,\n    syncCache = Cache.SyncCacheStrategy.CLEAR_TYPE_CACHE\n)\n</code></pre>"},{"location":"architecture-overview/#6-messaging-system","title":"6. Messaging System","text":""},{"location":"architecture-overview/#mongodb-based-message-queue","title":"MongoDB-Based Message Queue","text":"<p>Unique approach: Uses MongoDB collections as message queues.</p> <p>Key Features: - Topic-based routing - Exclusive vs broadcast delivery - Request/response patterns - Message persistence and durability - Change Stream integration for real-time processing</p>"},{"location":"architecture-overview/#message-processing-flow","title":"Message Processing Flow","text":"<pre><code>Sender \u2192 MongoDB Collection \u2192 Change Stream/Polling \u2192 Listener\n                 \u2193\n          Message Persistence\n</code></pre>"},{"location":"architecture-overview/#implementation-variants","title":"Implementation Variants","text":"<ul> <li>StdMessaging - Standard implementation</li> <li>AdvancedSplitCollectionMessaging - Scalable variant with collection splitting</li> </ul>"},{"location":"architecture-overview/#7-writer-system","title":"7. Writer System","text":""},{"location":"architecture-overview/#three-writer-types","title":"Three Writer Types","text":"<ol> <li>Synchronous Writer (<code>MorphiumWriter</code>)</li> <li>Immediate writes</li> <li>Strong consistency</li> <li> <p>Simple error handling</p> </li> <li> <p>Asynchronous Writer (<code>AsyncWriterImpl</code>)</p> </li> <li>Non-blocking writes</li> <li>Callback-based completion</li> <li> <p>Higher throughput</p> </li> <li> <p>Buffered Writer (<code>BufferedMorphiumWriterImpl</code>)</p> </li> <li>Write batching for performance</li> <li>Configurable buffer size and timeout</li> <li>Risk of data loss on system failure</li> </ol> <pre><code>@Entity\n@WriteBuffer(size = 1000, timeout = 5000, \n             strategy = WriteBuffer.STRATEGY.WRITE_OLD)\npublic class LogEntry {\n    // High-frequency writes use buffering\n}\n</code></pre>"},{"location":"architecture-overview/#threading-model","title":"Threading Model","text":""},{"location":"architecture-overview/#virtual-threads-jdk-21","title":"Virtual Threads (JDK 21+)","text":"<p>Morphium leverages virtual threads for better concurrency:</p> <pre><code>// Connection pool uses virtual thread factory\nScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(5,\n    Thread.ofVirtual().name(\"MCon-\", 0).factory());\n\n// Individual operations use virtual threads\nThread.ofVirtual().name(\"HeartbeatCheck-\" + host).start(() -&gt; {\n    // Heartbeat logic\n});\n</code></pre>"},{"location":"architecture-overview/#concurrency-patterns","title":"Concurrency Patterns","text":"<ol> <li>Connection Pool Management</li> <li>Lock-free connection borrowing/returning</li> <li>Atomic counters for statistics</li> <li> <p>ConcurrentHashMap for connection storage</p> </li> <li> <p>Cache Management</p> </li> <li>Lock-free cache access</li> <li>Atomic cache statistics</li> <li> <p>Background cache cleanup</p> </li> <li> <p>Message Processing</p> </li> <li>Configurable single/multi-threaded processing</li> <li>Thread-safe message listeners</li> <li>Concurrent message polling</li> </ol>"},{"location":"architecture-overview/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"architecture-overview/#modular-configuration-system","title":"Modular Configuration System","text":"<pre><code>MorphiumConfig {\n    ConnectionSettings connectionSettings;\n    ClusterSettings clusterSettings;\n    DriverSettings driverSettings;\n    MessagingSettings messagingSettings;\n    CacheSettings cacheSettings;\n    ThreadPoolSettings threadPoolSettings;\n    WriterSettings writerSettings;\n    // ... other settings\n}\n</code></pre>"},{"location":"architecture-overview/#configuration-sources","title":"Configuration Sources","text":"<ol> <li>Programmatic - Direct Java configuration</li> <li>Properties Files - Standard Java properties</li> <li>JSON - Structured JSON configuration</li> <li>Environment Variables - System environment</li> </ol>"},{"location":"architecture-overview/#extension-points","title":"Extension Points","text":""},{"location":"architecture-overview/#plugin-architecture","title":"Plugin Architecture","text":"<p>Morphium provides multiple extension points:</p> <ol> <li>Custom Drivers - Implement <code>MorphiumDriver</code> interface</li> <li>Name Providers - Custom collection naming strategies</li> <li>Object Mappers - Custom serialization logic</li> <li>Cache Implementations - JCache integration support</li> <li>Encryption Providers - Field-level encryption</li> <li>Lifecycle Listeners - Storage event hooks</li> </ol>"},{"location":"architecture-overview/#example-extension","title":"Example Extension","text":"<pre><code>// Custom name provider for time-based collections\npublic class TimeBasedNameProvider implements NameProvider {\n    @Override\n    public String getCollectionName(Class&lt;?&gt; type, ObjectMapper om, \n                                   boolean translateCamelCase, boolean useFQN, \n                                   String specifiedName, Morphium morphium) {\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyyMM\");\n        String date = df.format(new Date());\n        return specifiedName + \"_\" + date;\n    }\n}\n\n@Entity(nameProvider = TimeBasedNameProvider.class)\npublic class LogEntry {\n    // Will be stored in collections like \"log_entry_202412\"\n}\n</code></pre>"},{"location":"architecture-overview/#performance-architecture","title":"Performance Architecture","text":""},{"location":"architecture-overview/#key-performance-features","title":"Key Performance Features","text":"<ol> <li>Connection Pooling</li> <li>Reduces connection overhead</li> <li>Configurable pool sizes per host</li> <li> <p>Connection health monitoring</p> </li> <li> <p>Query Optimization</p> </li> <li>Index-aware query building</li> <li>Result caching at multiple levels</li> <li> <p>Projection support to limit data transfer</p> </li> <li> <p>Batching Support</p> </li> <li>Bulk write operations</li> <li>Message batching</li> <li> <p>Aggregation pipeline optimization</p> </li> <li> <p>Async Operations</p> </li> <li>Non-blocking I/O where possible</li> <li>Callback-based async API</li> <li>Virtual thread utilization</li> </ol>"},{"location":"architecture-overview/#memory-management","title":"Memory Management","text":"<ul> <li>Bounded caches with LRU eviction</li> <li>Connection lifecycle management</li> <li>Large result set streaming via iterators</li> <li>Reference counting for shared resources</li> </ul>"},{"location":"architecture-overview/#design-principles","title":"Design Principles","text":""},{"location":"architecture-overview/#1-annotation-driven-configuration","title":"1. Annotation-Driven Configuration","text":"<p>Minimal XML/configuration files, maximum annotation-based setup.</p>"},{"location":"architecture-overview/#2-fail-fast-philosophy","title":"2. Fail-Fast Philosophy","text":"<p>Early detection of configuration and runtime errors.</p>"},{"location":"architecture-overview/#3-extensibility","title":"3. Extensibility","text":"<p>Plugin architecture for customization without core changes.</p>"},{"location":"architecture-overview/#4-performance-first","title":"4. Performance First","text":"<p>Design decisions prioritize performance and scalability.</p>"},{"location":"architecture-overview/#5-mongodb-native","title":"5. MongoDB-Native","text":"<p>Deep integration with MongoDB features and concepts.</p>"},{"location":"architecture-overview/#6-type-safety","title":"6. Type Safety","text":"<p>Compile-time checking where possible, runtime validation where necessary.</p> <p>This architecture provides high performance, scalability, and flexibility while maintaining simplicity for common use cases and extensibility for advanced scenarios.</p>"},{"location":"configuration-reference/","title":"Configuration Reference","text":"<p>Complete reference for all Morphium configuration options.</p>"},{"location":"configuration-reference/#overview","title":"Overview","text":"<p><code>MorphiumConfig</code> uses nested settings objects for different subsystems:</p> <pre><code>MorphiumConfig cfg = new MorphiumConfig();\n\n// Access nested settings\ncfg.connectionSettings().setDatabase(\"myapp\");\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\ncfg.driverSettings().setDriverName(\"PooledDriver\");\n// ... other settings\n</code></pre>"},{"location":"configuration-reference/#connection-settings","title":"Connection Settings","text":"<p>Configure database connection parameters.</p> <pre><code>cfg.connectionSettings()\n</code></pre> Method Default Description <code>setDatabase(String)</code> required Database name to connect to <code>setConnectionTimeout(int)</code> 1000 Connection timeout in milliseconds <code>setSocketTimeout(int)</code> 0 Socket timeout in milliseconds (0 = no timeout) <code>setMaxConnectionIdleTime(int)</code> 100000 Max time connection can be idle (ms) <code>setMaxConnectionLifetime(int)</code> 600000 Max connection lifetime (ms) <code>setMinConnectionsPerHost(int)</code> 1 Minimum connections per host <code>setMaxConnectionsPerHost(int)</code> 100 Maximum connections per host <code>setMaxWaitTime(int)</code> 30000 Max wait time for connection from pool (ms)"},{"location":"configuration-reference/#cluster-settings","title":"Cluster Settings","text":"<p>Configure MongoDB cluster/replica set connection.</p> <pre><code>cfg.clusterSettings()\n</code></pre> Method Default Description <code>addHostToSeed(String, int)</code> required Add host:port to seed list <code>setReplicaSetName(String)</code> null Replica set name (auto-detected if null) <code>setHeartbeatFrequency(int)</code> 2000 Heartbeat frequency in milliseconds <code>setServerSelectionTimeout(int)</code> 2000 Server selection timeout (ms)"},{"location":"configuration-reference/#example","title":"Example","text":"<pre><code>// Single host\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\n\n// Replica set\ncfg.clusterSettings().addHostToSeed(\"mongo1\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo2\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo3\", 27017);\ncfg.clusterSettings().setReplicaSetName(\"myReplicaSet\");\n</code></pre>"},{"location":"configuration-reference/#driver-settings","title":"Driver Settings","text":"<p>Configure the MongoDB driver implementation.</p> <pre><code>cfg.driverSettings()\n</code></pre> Method Default Description <code>setDriverName(String)</code> \"PooledDriver\" Driver implementation to use <code>setIdleSleepTime(int)</code> 5 Sleep time between idle checks (ms)"},{"location":"configuration-reference/#available-drivers","title":"Available Drivers","text":"<ul> <li><code>PooledDriver</code> (default): Connection pooling with replica set support</li> <li><code>SingleMongoConnectDriver</code>: Single connection driver</li> <li><code>InMemDriver</code>: In-memory driver for testing</li> </ul>"},{"location":"configuration-reference/#authentication-settings","title":"Authentication Settings","text":"<p>Configure MongoDB authentication.</p> <pre><code>cfg.authSettings()\n</code></pre> Method Default Description <code>setMongoLogin(String)</code> null MongoDB username <code>setMongoPassword(String)</code> null MongoDB password <code>setMongoAdminUser(String)</code> null Admin user for replica set operations <code>setMongoAdminPwd(String)</code> null Admin password for replica set operations"},{"location":"configuration-reference/#example_1","title":"Example","text":"<pre><code>// Basic authentication\ncfg.authSettings().setMongoLogin(\"appuser\");\ncfg.authSettings().setMongoPassword(\"secret123\");\n\n// Admin user for replica set status (optional)\ncfg.authSettings().setMongoAdminUser(\"admin\");\ncfg.authSettings().setMongoAdminPwd(\"adminsecret\");\n</code></pre>"},{"location":"configuration-reference/#cache-settings","title":"Cache Settings","text":"<p>Configure the global caching behavior.</p> <pre><code>cfg.cacheSettings()\n</code></pre> Method Default Description <code>setGlobalCacheValidTime(int)</code> 5000 Global cache TTL in milliseconds <code>setHousekeepingTimeout(int)</code> 5000 Cache housekeeping interval (ms)"},{"location":"configuration-reference/#messaging-settings","title":"Messaging Settings","text":"<p>Configure the messaging system.</p> <pre><code>cfg.messagingSettings()\n</code></pre> Method Default Description <code>setMessageQueueName(String)</code> \"msg\" Base name for message collections <code>setMessagingWindowSize(int)</code> 100 Number of messages to process per batch <code>setMessagingMultithreadded(boolean)</code> true Enable multithreaded message processing <code>setUseChangeStream(boolean)</code> true Use MongoDB Change Streams for messaging <code>setPollPauseTime(int)</code> 500 Pause between message polls (ms)"},{"location":"configuration-reference/#thread-pool-settings","title":"Thread Pool Settings","text":"<p>Configure async operation thread pools.</p> <pre><code>cfg.threadPoolSettings()\n</code></pre> Method Default Description <code>setCorePoolSize(int)</code> 0 Core thread pool size <code>setMaxPoolSize(int)</code> Integer.MAX_VALUE Maximum thread pool size <code>setKeepAliveTime(int)</code> 60000 Thread keep-alive time (ms)"},{"location":"configuration-reference/#writer-settings","title":"Writer Settings","text":"<p>Configure write operation behavior.</p> <pre><code>cfg.writerSettings()\n</code></pre> Method Default Description <code>setBufferedWriterBufferSize(int)</code> 1000 Buffer size for buffered writes <code>setBufferedWriterTimeout(int)</code> 5000 Buffer flush timeout (ms)"},{"location":"configuration-reference/#object-mapping-settings","title":"Object Mapping Settings","text":"<p>Configure object mapping behavior.</p> <pre><code>cfg.objectMappingSettings()\n</code></pre> Method Default Description <code>setTreatCollectionAsUncapped(boolean)</code> false Treat all collections as uncapped <code>setObjectMapper(String)</code> \"ObjectMapperImpl\" Object mapper implementation"},{"location":"configuration-reference/#error-handling-settings","title":"Error Handling Settings","text":"<p>Configure retry and error handling behavior.</p> <pre><code>cfg.connectionSettings()\n</code></pre> Method Default Description <code>setRetriesOnNetworkError(int)</code> 5 Number of retries on network errors <code>setSleepBetweenErrorRetries(int)</code> 100 Sleep between error retries (ms)"},{"location":"configuration-reference/#configuration-sources","title":"Configuration Sources","text":"<p>Morphium supports multiple configuration sources:</p>"},{"location":"configuration-reference/#1-programmatic-configuration","title":"1. Programmatic Configuration","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp\");\n// ... other settings\n</code></pre>"},{"location":"configuration-reference/#2-properties-file","title":"2. Properties File","text":"<pre><code>Properties props = new Properties();\nprops.load(new FileInputStream(\"morphium.properties\"));\nMorphiumConfig cfg = new MorphiumConfig(props);\n</code></pre> <p>Example <code>morphium.properties</code>: <pre><code>database=myapp\nhosts=mongo1:27017,mongo2:27017,mongo3:27017\nreplica_set_name=myReplicaSet\ndriver_name=PooledDriver\nmax_connections_per_host=50\nmongo_login=appuser\nmongo_password=secret123\n</code></pre></p>"},{"location":"configuration-reference/#3-json-configuration","title":"3. JSON Configuration","text":"<pre><code>String json = Files.readString(Paths.get(\"morphium-config.json\"));\nMorphiumConfig cfg = MorphiumConfig.createFromJson(json);\n</code></pre> <p>Example JSON: <pre><code>{\n  \"database\": \"myapp\",\n  \"hosts\": [\"mongo1:27017\", \"mongo2:27017\", \"mongo3:27017\"],\n  \"replicaSetName\": \"myReplicaSet\",\n  \"driverName\": \"PooledDriver\",\n  \"maxConnectionsPerHost\": 50,\n  \"mongoLogin\": \"appuser\",\n  \"mongoPassword\": \"secret123\"\n}\n</code></pre></p>"},{"location":"configuration-reference/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"configuration-reference/#development","title":"Development","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp_dev\");\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\ncfg.driverSettings().setDriverName(\"PooledDriver\");\ncfg.connectionSettings().setMaxConnectionsPerHost(10); // Lower for dev\n</code></pre>"},{"location":"configuration-reference/#testing","title":"Testing","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp_test\");\ncfg.driverSettings().setDriverName(\"InMemDriver\"); // In-memory for tests\n</code></pre>"},{"location":"configuration-reference/#production","title":"Production","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp_prod\");\ncfg.clusterSettings().addHostToSeed(\"mongo1\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo2\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo3\", 27017);\ncfg.connectionSettings().setMaxConnectionsPerHost(100);\ncfg.connectionSettings().setMaxWaitTime(10000);\ncfg.authSettings().setMongoLogin(\"produser\");\ncfg.authSettings().setMongoPassword(System.getenv(\"MONGO_PASSWORD\"));\n</code></pre>"},{"location":"configuration-reference/#common-configuration-patterns","title":"Common Configuration Patterns","text":""},{"location":"configuration-reference/#high-throughput","title":"High Throughput","text":"<pre><code>cfg.connectionSettings().setMaxConnectionsPerHost(200);\ncfg.connectionSettings().setMaxWaitTime(5000);\ncfg.messagingSettings().setMessagingWindowSize(500);\ncfg.messagingSettings().setMessagingMultithreadded(true);\n</code></pre>"},{"location":"configuration-reference/#low-latency","title":"Low Latency","text":"<pre><code>cfg.connectionSettings().setMinConnectionsPerHost(20);\ncfg.connectionSettings().setConnectionTimeout(500);\ncfg.connectionSettings().setMaxWaitTime(1000);\ncfg.clusterSettings().setHeartbeatFrequency(1000);\n</code></pre>"},{"location":"configuration-reference/#high-availability","title":"High Availability","text":"<pre><code>cfg.connectionSettings().setRetriesOnNetworkError(10);\ncfg.connectionSettings().setSleepBetweenErrorRetries(200);\ncfg.clusterSettings().setServerSelectionTimeout(5000);\ncfg.connectionSettings().setMaxConnectionIdleTime(300000);\n</code></pre>"},{"location":"contributing/","title":"Contributing to Documentation","text":"<p>This guide explains how to contribute to and work with the Morphium documentation.</p>"},{"location":"contributing/#viewing-the-documentation","title":"Viewing the Documentation","text":""},{"location":"contributing/#online","title":"Online","text":"<p>Visit the published documentation at: https://sboesebeck.github.io/morphium/</p>"},{"location":"contributing/#local-development","title":"Local Development","text":"<ol> <li> <p>Install MkDocs and Material theme: <pre><code>pip install mkdocs-material\n</code></pre></p> </li> <li> <p>Serve locally: <pre><code>mkdocs serve\n</code></pre>    Then open http://127.0.0.1:8000</p> </li> <li> <p>Build static site: <pre><code>mkdocs build\n</code></pre>    Output will be in the <code>site/</code> directory.</p> </li> </ol>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                          # Home page\n\u251c\u2500\u2500 overview.md                       # Getting started overview\n\u251c\u2500\u2500 architecture-overview.md          # Architecture details\n\u251c\u2500\u2500 developer-guide.md                # Developer guide\n\u251c\u2500\u2500 messaging.md                      # Messaging system\n\u251c\u2500\u2500 api-reference.md                  # API reference\n\u251c\u2500\u2500 configuration-reference.md        # Configuration options\n\u251c\u2500\u2500 performance-scalability-guide.md  # Performance tuning\n\u251c\u2500\u2500 production-deployment-guide.md    # Production deployment\n\u251c\u2500\u2500 monitoring-metrics-guide.md       # Monitoring and metrics\n\u251c\u2500\u2500 security-guide.md                 # Security best practices\n\u251c\u2500\u2500 troubleshooting-guide.md          # Troubleshooting\n\u2514\u2500\u2500 howtos/                           # How-to guides\n    \u251c\u2500\u2500 basic-setup.md\n    \u251c\u2500\u2500 migration-v5-to-v6.md\n    \u251c\u2500\u2500 inmemory-driver.md\n    \u251c\u2500\u2500 aggregation-examples.md\n    \u251c\u2500\u2500 caching-examples.md\n    \u251c\u2500\u2500 cache-patterns.md\n    \u251c\u2500\u2500 field-names.md\n    \u2514\u2500\u2500 messaging-implementations.md\n</code></pre>"},{"location":"contributing/#automated-deployment","title":"Automated Deployment","text":"<p>The documentation is automatically deployed to GitHub Pages when changes are pushed to the <code>master</code> or <code>develop</code> branch.</p>"},{"location":"contributing/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<ul> <li>File: <code>.github/workflows/deploy-docs.yml</code></li> <li>Triggers on: Push to <code>master</code>/<code>develop</code> with changes to <code>docs/**</code> or <code>mkdocs.yml</code></li> <li>Manual trigger: Available via GitHub Actions UI</li> </ul>"},{"location":"contributing/#how-it-works","title":"How it works:","text":"<ol> <li>Checks out the repository</li> <li>Installs Python and MkDocs dependencies</li> <li>Builds the documentation site</li> <li>Deploys to the <code>gh-pages</code> branch</li> <li>GitHub Pages serves the content</li> </ol>"},{"location":"contributing/#navigation-features","title":"Navigation Features","text":"<p>The Material theme provides: - Tabbed Navigation: Top-level categories - Sidebar Navigation: Nested page structure - Search: Full-text search across all docs - Dark/Light Mode: Theme switcher - Code Highlighting: Syntax highlighting for code blocks - Mobile Responsive: Works on all devices - Table of Contents: Per-page TOC on the right</p>"},{"location":"contributing/#editing-documentation","title":"Editing Documentation","text":"<ol> <li>Edit Markdown files in the <code>docs/</code> directory</li> <li>Add new pages to <code>mkdocs.yml</code> navigation</li> <li>Test locally with <code>mkdocs serve</code></li> <li>Commit and push to trigger automatic deployment</li> </ol>"},{"location":"contributing/#markdown-extensions","title":"Markdown Extensions","text":"<p>Supported features: - Admonitions: <code>!!! note</code>, <code>!!! warning</code>, etc. - Code Blocks: Triple backticks with syntax highlighting - Tables: Standard Markdown tables - Tabbed Content: Using pymdownx.tabbed - Task Lists: <code>- [ ]</code> and <code>- [x]</code></p>"},{"location":"contributing/#theme-configuration","title":"Theme Configuration","text":"<p>The Material theme is configured in <code>mkdocs.yml</code>: - Colors: Indigo primary/accent - Features: Navigation tabs, expand sections, search suggestions - Plugins: Search, tags - Social: GitHub repository link</p>"},{"location":"contributing/#troubleshooting","title":"Troubleshooting","text":"<p>Issue: Theme not found <pre><code>pip install mkdocs-material\n</code></pre></p> <p>Issue: Build fails <pre><code>mkdocs build --strict  # Shows detailed errors\n</code></pre></p> <p>Issue: Navigation not updating - Check <code>mkdocs.yml</code> nav structure - Ensure file paths are correct relative to <code>docs/</code></p>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>When adding new documentation: 1. Place in appropriate directory (<code>docs/</code> or <code>docs/howtos/</code>) 2. Update <code>mkdocs.yml</code> navigation 3. Use consistent heading levels (H1 for title, H2 for sections) 4. Add code examples where applicable 5. Test locally before committing</p>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>This guide explains how to configure Morphium and use its core APIs.</p>"},{"location":"developer-guide/#configuration-model","title":"Configuration Model","text":"<ul> <li><code>MorphiumConfig</code> aggregates dedicated settings objects. Use these nested accessors:</li> <li><code>connectionSettings()</code> \u2013 database name, pool sizes, timeouts</li> <li><code>clusterSettings()</code> \u2013 host seed, replica set</li> <li><code>driverSettings()</code> \u2013 driver name (<code>PooledDriver</code>, <code>SingleMongoConnectDriver</code>, <code>InMemDriver</code>), idle sleeps</li> <li><code>messagingSettings()</code> \u2013 queue name, window size, multithreading, change streams, poll pause</li> <li><code>cacheSettings()</code> \u2013 global TTL, housekeeping, cache implementation</li> <li><code>threadPoolSettings()</code> \u2013 async operation thread pool</li> <li><code>writerSettings()</code> \u2013 write buffer behavior and writer implementation</li> <li><code>objectMappingSettings()</code> \u2013 camelCase conversion, lifecycle options</li> <li><code>encryptionSettings()</code> \u2013 value and credentials encryption providers/keys</li> <li><code>collectionCheckSettings()</code> \u2013 index/capped checks</li> <li><code>authSettings()</code> \u2013 MongoDB credentials</li> </ul>"},{"location":"developer-guide/#example","title":"Example","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp\");\ncfg.clusterSettings().addHostToSeed(\"mongo1\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo2\", 27017);\ncfg.driverSettings().setDriverName(\"PooledDriver\"); // default\n\n// Optional: messaging defaults\ncfg.messagingSettings().setMessageQueueName(\"msg\");\ncfg.messagingSettings().setMessagingWindowSize(100);\ncfg.messagingSettings().setMessagingMultithreadded(true);\ncfg.messagingSettings().setUseChangeStream(true);\n</code></pre>"},{"location":"developer-guide/#object-mapping","title":"Object Mapping","text":"<ul> <li>Use annotations on POJOs: <code>@Entity</code>, <code>@Embedded</code>, <code>@Id</code>, <code>@Reference(lazyLoading=true)</code>, <code>@Cache</code>, <code>@Index</code></li> <li>Field\u2011level encryption: <code>@Encrypted</code> (requires an encryption provider/key)</li> </ul> <p>hint: All times and timeout settings are in milliseconds throughout whole Morphium</p>"},{"location":"developer-guide/#example_1","title":"Example","text":"<pre><code>@Entity(translateCamelCase = true)\n@Cache(timeout = 60_000)\npublic class Order {\n  @Id private MorphiumId id;\n  @Index private String customerId;\n  private BigDecimal amount;\n\n  @Reference(lazyLoading = true)\n  private List&lt;Item&gt; items;\n\n  @Embedded\n  private Address shippingAddress;\n}\n</code></pre>"},{"location":"developer-guide/#embedded-vs-reference","title":"Embedded vs Reference","text":"<ul> <li>Embedded (<code>@Embedded</code>):</li> <li>No MongoDB <code>_id</code> required; data is stored inline inside the parent document.</li> <li>Ideal for value objects and nested structures (address, money, coords).</li> <li>One read/write touches a single MongoDB document; deserialization splits into Java objects.</li> <li>Supports <code>typeId</code>, <code>translateCamelCase</code>, and <code>polymorph</code> like <code>@Entity</code>.</li> <li>Reference (<code>@Reference</code>):</li> <li>Stores only the target entity\u2019s ID in the parent; the referenced entity lives in its own collection/document.</li> <li>Reading references may incur N+1 queries: one for the parent plus one per referenced entity (unless <code>lazyLoading=true</code> defers loads until first access).</li> <li>Use for large/independent aggregates or when the referenced object changes on its own lifecycle.</li> </ul>"},{"location":"developer-guide/#simple-example","title":"Simple Example","text":"<pre><code>@Embedded(typeId = \"Address\")\npublic class Address {\n  private String street;\n  private String city;\n}\n\n@Entity(typeId = \"Customer\")\npublic class Customer {\n  @Id private MorphiumId id;\n  private String name;\n}\n\n@Entity(typeId = \"Order\")\npublic class Order {\n  @Id private MorphiumId id;\n\n  // Embedded: stored inline in the Order document\n  @Embedded private Address shippingAddress;\n\n  // Reference: only the Customer ID is stored in Order; Customer lives in its own collection\n  @Reference(lazyLoading = true) private Customer customer;\n}\n</code></pre>"},{"location":"developer-guide/#notes","title":"Notes","text":"<ul> <li>When reading an <code>Order</code>, Morphium returns <code>shippingAddress</code> from the same document. The <code>customer</code> is loaded on first access due to <code>lazyLoading</code> (otherwise N+1 reads if you eagerly access many references).</li> <li>The MongoDB <code>orders</code> collection holds full address fields inline; customers are separate documents in the <code>customer</code> collection.</li> </ul>"},{"location":"developer-guide/#further-examples-in-tests","title":"Further Examples in Tests","text":"<ul> <li><code>EmbeddedObject</code> used across tests: src/test/java/de/caluga/test/mongo/suite/data/EmbeddedObject.java</li> <li>GitHub: https://github.com/sboesebeck/morphium/blob/develop/src/test/java/de/caluga/test/mongo/suite/data/EmbeddedObject.java</li> <li><code>ComplexObject</code> demonstrates embedded lists and references: src/test/java/de/caluga/test/mongo/suite/data/ComplexObject.java</li> <li>GitHub: https://github.com/sboesebeck/morphium/blob/develop/src/test/java/de/caluga/test/mongo/suite/data/ComplexObject.java Note: these test classes are intentionally technical and cover edge cases.</li> </ul>"},{"location":"developer-guide/#stable-type-identification-recommended","title":"Stable Type Identification (recommended)","text":"<ul> <li>Prefer specifying a stable type identifier on your classes to avoid coupling persisted data to Java class names. This makes refactors and package/class renames safer.</li> <li>Entities: set <code>@Entity(typeId = \"Order\")</code> (choose any stable string meaningful to your domain).</li> <li>Embedded types: set <code>@Embedded(typeId = \"Address\")</code> likewise.</li> <li>Morphium uses the <code>typeId</code> (when provided) instead of the Java class name to identify the target POJO for incoming data. This decouples stored documents from Java class names and eases migrations when packages or class names change. <pre><code>@Entity(typeId = \"Order\", translateCamelCase = true)\npublic class Order { /* ... */ }\n\n@Embedded(typeId = \"Address\")\npublic class Address { /* ... */ }\n</code></pre></li> </ul>"},{"location":"developer-guide/#notes_1","title":"Notes","text":"<ul> <li><code>typeId</code> is available on both <code>@Entity</code> and <code>@Embedded</code>.</li> <li>For heterogeneous collections/fields, you can also enable <code>polymorph = true</code> to include type information in the stored documents.</li> <li>Important: set a <code>typeId</code> from the beginning. If you first store documents without <code>typeId</code>, Morphium will persist the Java class name; after a rename or package move those documents may no longer deserialize. You can set <code>typeId</code> in the new version to the old fully\u2011qualified class name as a recovery step, but it is ugly and potentially confusing\u2014prefer setting a stable <code>typeId</code> from day one.</li> </ul>"},{"location":"developer-guide/#renames-and-schema-evolution","title":"Renames and Schema Evolution","text":"<ul> <li>Field renames: use <code>@Aliases({\"oldName1\", \"oldName2\"})</code> on the new field to accept legacy field names from MongoDB and in queries during migration. <pre><code>public class User {\n  @Aliases({\"name\", \"user_name\"})\n  private String userName;\n}\n</code></pre></li> <li>Additional/dynamic fields: add a catch\u2011all <code>Map&lt;String,Object&gt;</code> annotated with <code>@AdditionalData</code> to retain unknown fields that exist in MongoDB but not in your POJO. <pre><code>public class User {\n  @AdditionalData(readOnly = true) // set false if you want to write them back\n  private Map&lt;String,Object&gt; extras;\n}\n</code></pre></li> <li>Combine <code>typeId</code> with <code>@Aliases</code> and <code>@AdditionalData</code> for smoother migrations: keep deserialization working after refactors, accept legacy field names, and preserve unexpected fields.</li> </ul>"},{"location":"developer-guide/#example-rename-class-and-fields-safely","title":"Example: Rename Class and Fields Safely","text":""},{"location":"developer-guide/#version-1-initial-best-practice","title":"Version 1 (initial, best practice)","text":"<pre><code>// package com.example.v1;\n@Entity(typeId = \"User\") // set a stable typeId from day one\npublic class User {\n  @Id private MorphiumId id;\n  private String name;            // old field name\n  private int age;\n}\n</code></pre>"},{"location":"developer-guide/#version-2-after-refactormigration","title":"Version 2 (after refactor/migration)","text":"<pre><code>// package com.example.accounts;    // class/package renamed\n@Entity(typeId = \"User\")           // stable type identifier\npublic class AccountUser {          // class renamed\n  @Id private MorphiumId id;\n\n  // field renamed; accept legacy names from existing MongoDB docs\n  @Aliases({\"name\", \"user_name\"})\n  private String userName;\n\n  private int age;\n\n  // capture unknown/dynamic fields to avoid data loss during migration\n  @AdditionalData(readOnly = true)\n  private Map&lt;String,Object&gt; extras;\n}\n</code></pre>"},{"location":"developer-guide/#recovery-if-v1-had-no-typeid","title":"Recovery (if v1 had no <code>typeId</code>)","text":"<ul> <li>If v1 stored the Java class name, set <code>@Entity(typeId = \"com.example.v1.User\")</code> in v2 so existing documents still deserialize. Then plan a data migration to switch to a clean, stable <code>typeId</code> later.</li> </ul>"},{"location":"developer-guide/#notes_2","title":"Notes","text":"<ul> <li>Existing documents continue to deserialize because <code>typeId = \"User\"</code> no longer depends on the Java class name.</li> <li>Legacy documents with <code>name</code> (or <code>user_name</code> if camelCase translation changed) populate <code>userName</code> thanks to <code>@Aliases</code>.</li> <li>Any unexpected fields present in legacy documents are preserved in <code>extras</code>.</li> </ul>"},{"location":"developer-guide/#querying","title":"Querying","text":"<pre><code>// Find one\nOrder o = morphium.createQueryFor(Order.class)\n    .f(\"customerId\").eq(\"C123\")\n    .get();\n\n// Find many with projection/sort\nList&lt;Order&gt; recent = morphium.createQueryFor(Order.class)\n    .f(\"status\").eq(\"OPEN\")\n    .sort(\"-created\")\n    .asList();\n</code></pre>"},{"location":"developer-guide/#field-names-avoid-string-literals","title":"Field Names (avoid string literals)","text":"<ul> <li>Prefer enums over string field names to avoid typos and ease migrations/renames. <pre><code>@Entity(translateCamelCase = true)\npublic class User {\n  @Id private MorphiumId id;\n  private String userName; // stored as user_name\n\n  public enum Fields { id, userName }\n}\n\n// Safer queries using enums\nvar q = morphium.createQueryFor(User.class)\n    .f(User.Fields.userName).eq(\"alice\");\n</code></pre></li> <li>Alternative without codegen: use the lambda property extractor helper <pre><code>import static de.caluga.morphium.query.FieldNames.of;\nvar q2 = morphium.createQueryFor(User.class)\n    .f(of(User::getUserName)).eq(\"alice\");\n</code></pre></li> <li>Enums/lambdas remain stable across refactors and camelCase translation changes.</li> <li>See How\u2011To: Field Names for more options (including annotation\u2011processor codegen).</li> </ul>"},{"location":"developer-guide/#aggregation","title":"Aggregation","text":"<p><pre><code>var agg = morphium.createAggregator(Order.class, Map.class);\nagg.match(morphium.createQueryFor(Order.class).f(\"status\").eq(\"OPEN\"));\nagg.group(\"$customerId\").sum(\"total\", \"$amount\").count(\"cnt\").end();\nagg.sort(\"-total\");\nList&lt;Map&gt; results = agg.aggregate();\n</code></pre> See How\u2011To: Aggregation Examples for more pipelines.</p>"},{"location":"developer-guide/#caching","title":"Caching","text":"<ul> <li>Add <code>@Cache</code> to entities to enable read cache; TTL, max entries, and clear strategy are configurable.</li> <li>Cluster\u2011wide cache synchronization uses Morphium\u2019s messaging; see the Messaging guide.</li> <li>A JCache adapter is available if you prefer standard javax.cache interfaces. See How\u2011To: Caching Examples and Cache Patterns for recipes and guidance.</li> </ul>"},{"location":"developer-guide/#cache-synchronization","title":"Cache Synchronization","text":"<ul> <li>Purpose: keep caches consistent across nodes. Messaging was originally introduced to propagate cache change events in clusters.</li> <li>Mechanism: on writes, Morphium emits a cache message; other nodes apply a policy from <code>@Cache.syncCache</code>:</li> <li><code>CLEAR_TYPE_CACHE</code>: clear the entire type cache for the entity.</li> <li><code>REMOVE_ENTRY_FROM_TYPE_CACHE</code>: remove a single entry (by ID) from the cache.</li> <li><code>UPDATE_ENTRY</code>: re\u2011read and update the cached entity in place (may briefly expose stale data under concurrent reads\u2014\u201cdirty reads\u201d).</li> <li>Requirements: ensure messaging is running on all nodes; change streams improve responsiveness and reduce polling (replica set required).</li> <li>Setup snippet: <pre><code>var messaging = morphium.createMessaging();\nmessaging.start();\nnew MessagingCacheSynchronizer(messaging, morphium); // attach synchronizer\n</code></pre></li> </ul>"},{"location":"developer-guide/#encryption","title":"Encryption","text":"<ul> <li>Annotate sensitive fields with <code>@Encrypted</code> and configure providers/keys via <code>cfg.encryptionSettings()</code>. <pre><code>cfg.encryptionSettings().setCredentialsEncryptionKey(\"secret\");\n// Optional: custom providers\n// cfg.encryptionSettings().setEncryptionKeyProviderClass(...);\n// cfg.encryptionSettings().setValueEncryptionProviderClass(...);\n</code></pre></li> </ul>"},{"location":"developer-guide/#threading","title":"Threading","text":"<ul> <li>Async operations run on a dedicated thread pool (virtual threads by default) configured via <code>threadPoolSettings()</code>.</li> <li>Messaging has its own thread pool configuration in <code>messagingSettings()</code>.</li> </ul>"},{"location":"developer-guide/#extension-points","title":"Extension Points","text":"<ul> <li>NameProvider: dynamic collection naming <pre><code>morphium.setNameProviderForClass(MyEntity.class, (m, cls, def) -&gt; def + \"_2025\");\n</code></pre></li> <li>Storage listeners: audit/validation hooks <pre><code>morphium.addListener(new MorphiumStorageAdapter&lt;Object&gt;() {\n  @Override public void preStore(Morphium m, Object entity, boolean isNew) {\n    // audit or validation\n  }\n});\n</code></pre></li> <li>Custom cache/writer/type mappers: implement the respective interfaces and register via config or Morphium API.</li> </ul>"},{"location":"developer-guide/#see-also","title":"See Also","text":"<ul> <li>Messaging: topic listeners, exclusive vs broadcast, change streams vs polling</li> <li>How\u2011Tos for focused recipes: start at Basic Setup</li> </ul>"},{"location":"inmemory-driver/","title":"InMemory Driver","text":"<p>The InMemoryDriver provides a fully in-memory MongoDB-compatible database that runs embedded in your application. It's perfect for:</p> <ul> <li>Unit Testing: No MongoDB installation required</li> <li>CI/CD Pipelines: Fast, isolated test environments</li> <li>Development: Local development without Docker/MongoDB</li> <li>Embedded Applications: Ship with a built-in database</li> <li>Microservices: Lightweight in-process data storage</li> </ul> <p>Note: For running MorphiumServer as a standalone MongoDB-compatible server, see MorphiumServer.</p>"},{"location":"inmemory-driver/#quick-start","title":"Quick Start","text":"<p>Set the driver name to <code>InMemDriver</code>: <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"testdb\");\ncfg.driverSettings().setDriverName(\"InMemDriver\");\n\nMorphium morphium = new Morphium(cfg);\n</code></pre></p> <p>Or use environment variable: <pre><code>export MORPHIUM_DRIVER=inmem\nmvn test\n</code></pre></p> <p>Or system property: <pre><code>mvn test -Dmorphium.driver=inmem\n</code></pre></p>"},{"location":"inmemory-driver/#supported-features-v60","title":"Supported Features (v6.0)","text":""},{"location":"inmemory-driver/#core-operations","title":"Core Operations","text":"<ul> <li>\u2705 CRUD Operations: insert, find, update, delete, upsert</li> <li>\u2705 Queries: $eq, $ne, $gt, $gte, $lt, $lte, $in, $nin, $exists, $regex</li> <li>\u2705 Logical Operators: $and, $or, $not, $nor</li> <li>\u2705 Array Operators: $elemMatch, $all, $size</li> <li>\u2705 Projections: Field inclusion/exclusion, nested fields</li> <li>\u2705 Sorting &amp; Pagination: sort(), skip(), limit()</li> </ul>"},{"location":"inmemory-driver/#aggregation-pipeline","title":"Aggregation Pipeline","text":"<ul> <li>\u2705 Basic Stages: $match, $group, $sort, $limit, $skip, $project</li> <li>\u2705 Group Operators: $sum, $avg, $min, $max, $first, $last, $push, $addToSet</li> <li>\u2705 MapReduce: Full JavaScript-based MapReduce with GraalJS engine</li> <li>\u26a0\ufe0f Advanced Stages: $lookup, $unwind, $facet (limited support)</li> </ul>"},{"location":"inmemory-driver/#change-streams-v60","title":"Change Streams (v6.0)","text":"<ul> <li>\u2705 Event Types: insert, update, delete, drop operations</li> <li>\u2705 Document Snapshots: Immutable snapshots prevent dirty reads</li> <li>\u2705 Pipeline Filtering: Filter events with aggregation pipelines</li> <li>\u2705 Full Document Support: Access complete document in change events</li> <li>\u2705 Database-scoped Sharing: Multiple Morphium instances share driver per database</li> </ul>"},{"location":"inmemory-driver/#messaging-system-v60","title":"Messaging System (v6.0)","text":"<ul> <li>\u2705 StandardMessaging: Single-collection messaging with change streams</li> <li>\u2705 MultiCollectionMessaging: Multi-collection messaging</li> <li>\u2705 Exclusive Messages: Single-consumer message processing</li> <li>\u2705 Broadcast Messages: Multi-consumer message distribution</li> <li>\u2705 Message Locking: Proper lock collection support</li> </ul>"},{"location":"inmemory-driver/#indexes","title":"Indexes","text":"<ul> <li>\u2705 Single Field Indexes: Basic indexing support</li> <li>\u26a0\ufe0f Compound Indexes: Limited support</li> <li>\u274c Text Indexes: Not fully implemented</li> <li>\u274c Geospatial Indexes: Limited geospatial support</li> </ul>"},{"location":"inmemory-driver/#transactions","title":"Transactions","text":"<ul> <li>\u2705 Basic Transactions: start, commit, abort (single-instance)</li> <li>\u274c Multi-document ACID: Limited to single instance</li> <li>\u274c Distributed Transactions: No replica set support</li> </ul>"},{"location":"inmemory-driver/#v60-improvements","title":"V6.0 Improvements","text":""},{"location":"inmemory-driver/#change-stream-enhancements","title":"Change Stream Enhancements","text":"<p>The v6.0 release significantly improved change stream reliability:</p> <p>Deep Copy Snapshots <pre><code>// Documents are deep-copied before change stream events are dispatched\n// This prevents dirty reads where documents are modified before callbacks execute\nmorphium.watch(UncachedObject.class, evt -&gt; {\n    // evt.getFullDocument() contains an immutable snapshot\n    // Safe to process without worrying about concurrent modifications\n});\n</code></pre></p> <p>Database-scoped Driver Sharing <pre><code>// Multiple Morphium instances sharing the same database will share the driver\nMorphiumConfig cfg1 = new MorphiumConfig();\ncfg1.connectionSettings().setDatabase(\"testdb\");\ncfg1.driverSettings().setDriverName(\"InMemDriver\");\nMorphium m1 = new Morphium(cfg1);\n\nMorphiumConfig cfg2 = new MorphiumConfig();\ncfg2.connectionSettings().setDatabase(\"testdb\");  // same database\ncfg2.driverSettings().setDriverName(\"InMemDriver\");\nMorphium m2 = new Morphium(cfg2);\n\n// m1 and m2 share the same InMemoryDriver instance\n// Change streams work correctly across both instances\n// Driver is only closed when the last Morphium instance closes\n</code></pre></p> <p>Reference Counting - Automatic reference counting prevents premature driver shutdown - Each Morphium instance increments the ref count on creation - Driver shuts down only when ref count reaches zero - Solves issues with tests that create multiple Morphium instances</p>"},{"location":"inmemory-driver/#messaging-improvements","title":"Messaging Improvements","text":"<p>No More Re-reads <pre><code>// v5: messaging layer re-read documents from change stream events\n// v6: uses evt.getFullDocument() directly - more efficient, no dirty reads\nMorphiumMessaging msg = morphium.createMessaging();\nmsg.addListenerForTopic(\"events\", (m, message) -&gt; {\n    // message is from the immutable snapshot, not a re-read\n    return null;\n});\n</code></pre></p> <p>Better Multi-Instance Support <pre><code>// Tests with multiple messaging instances now work correctly\nMorphium m1 = new Morphium(cfg);\nMorphium m2 = new Morphium(cfg);  // same database\n\nMorphiumMessaging msg1 = m1.createMessaging();\nMorphiumMessaging msg2 = m2.createMessaging();\n\n// Both receive change stream events correctly\n// Exclusive messages work as expected\n// Broadcast messages delivered to all listeners\n</code></pre></p>"},{"location":"inmemory-driver/#mapreduce-support","title":"MapReduce Support","text":"<p>The InMemory driver includes full MapReduce support using JavaScript (GraalJS engine).</p>"},{"location":"inmemory-driver/#basic-mapreduce-example","title":"Basic MapReduce Example","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.driverSettings().setDriverName(\"InMemDriver\");\ncfg.connectionSettings().setDatabase(\"testdb\");\n\ntry (Morphium morphium = new Morphium(cfg)) {\n    // Insert sample data\n    for (int i = 0; i &lt; 100; i++) {\n        MyEntity entity = new MyEntity();\n        entity.setCategory(i % 5);  // 5 categories\n        entity.setValue(i);\n        morphium.store(entity);\n    }\n\n    // Define map function (JavaScript)\n    String mapFunction = \"\"\"\n        function() {\n            emit(this.category, this.value);\n        }\n        \"\"\";\n\n    // Define reduce function (JavaScript)\n    String reduceFunction = \"\"\"\n        function(key, values) {\n            return values.reduce((sum, val) =&gt; sum + val, 0);\n        }\n        \"\"\";\n\n    // Execute MapReduce\n    List&lt;Map&lt;String, Object&gt;&gt; results = morphium.mapReduce(\n        MyEntity.class,\n        mapFunction,\n        reduceFunction\n    );\n\n    // Process results\n    for (Map&lt;String, Object&gt; result : results) {\n        System.out.println(\"Category: \" + result.get(\"_id\") +\n                         \", Total: \" + result.get(\"value\"));\n    }\n}\n</code></pre>"},{"location":"inmemory-driver/#mapreduce-with-query-filter","title":"MapReduce with Query Filter","text":"<pre><code>// Only process documents matching a query\nMap&lt;String, Object&gt; query = Doc.of(\"category\", Doc.of(\"$gte\", 2));\n\nList&lt;Map&lt;String, Object&gt;&gt; results = morphium.mapReduce(\n    MyEntity.class,\n    mapFunction,\n    reduceFunction,\n    query\n);\n</code></pre>"},{"location":"inmemory-driver/#mapreduce-with-finalize","title":"MapReduce with Finalize","text":"<pre><code>String finalizeFunction = \"\"\"\n    function(key, reducedValue) {\n        return {\n            category: key,\n            total: reducedValue,\n            average: reducedValue / 20  // Assuming 20 docs per category\n        };\n    }\n    \"\"\";\n\nList&lt;Map&lt;String, Object&gt;&gt; results = morphium.mapReduceWithFinalize(\n    MyEntity.class,\n    mapFunction,\n    reduceFunction,\n    query,\n    finalizeFunction\n);\n</code></pre>"},{"location":"inmemory-driver/#word-count-example","title":"Word Count Example","text":"<pre><code>// Classic MapReduce word count example\nString mapFunction = \"\"\"\n    function() {\n        var words = this.text.split(/\\\\s+/);\n        words.forEach(function(word) {\n            emit(word.toLowerCase(), 1);\n        });\n    }\n    \"\"\";\n\nString reduceFunction = \"\"\"\n    function(key, values) {\n        return values.reduce((sum, val) =&gt; sum + val, 0);\n    }\n    \"\"\";\n\nList&lt;Map&lt;String, Object&gt;&gt; wordCounts = morphium.mapReduce(\n    Document.class,\n    mapFunction,\n    reduceFunction\n);\n\n// Results: [{_id: \"hello\", value: 5}, {_id: \"world\", value: 3}, ...]\n</code></pre>"},{"location":"inmemory-driver/#javascript-engine-details","title":"JavaScript Engine Details","text":"<ul> <li>Engine: GraalJS (modern JavaScript engine)</li> <li>Compatibility: Supports ES6+ JavaScript features (arrow functions, destructuring, etc.)</li> <li>Functions Available:</li> <li><code>emit(key, value)</code> - Emit key-value pairs from map function</li> <li>Standard JavaScript built-ins (Array methods, Math, Date, String, JSON, etc.)</li> <li>ES6 features: <code>forEach</code>, <code>map</code>, <code>reduce</code>, <code>filter</code>, arrow functions, template literals</li> </ul>"},{"location":"inmemory-driver/#performance-considerations","title":"Performance Considerations","text":"<p>MapReduce in InMemory driver is: - \u2705 Fast: All in-memory, no disk I/O - \u2705 Single-threaded: Simpler, predictable execution - \u26a0\ufe0f Memory-bound: Large datasets may consume significant RAM - \u26a0\ufe0f No distribution: Cannot scale across multiple nodes</p> <p>For large-scale MapReduce, consider using real MongoDB with sharding.</p>"},{"location":"inmemory-driver/#limitations","title":"Limitations","text":""},{"location":"inmemory-driver/#not-supported","title":"Not Supported","text":"<ul> <li>\u274c Replica Sets: No replica set simulation</li> <li>\u274c Sharding: No shard key or distributed queries</li> <li>\u274c Full Text Search: Limited $text operator support</li> <li>\u274c Advanced Geospatial: Basic $near/$geoWithin only</li> <li>\u274c GridFS: No file storage support</li> <li>\u274c Time Series Collections: Not implemented</li> <li>\u274c Authentication: No user/role management</li> <li>\u274c $lookup Joins: Not yet implemented</li> </ul>"},{"location":"inmemory-driver/#performance-considerations_1","title":"Performance Considerations","text":"<ul> <li>Memory Usage: All data stored in memory</li> <li>No Persistence: Data lost when driver closes</li> <li>Concurrency: Uses ReadWriteLock for thread safety</li> <li>Index Performance: Limited compared to MongoDB's B-tree indexes</li> </ul>"},{"location":"inmemory-driver/#testing-strategies","title":"Testing Strategies","text":""},{"location":"inmemory-driver/#unit-tests","title":"Unit Tests","text":"<pre><code>@Test\npublic void testWithInMemory() {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.driverSettings().setDriverName(\"InMemDriver\");\n    cfg.connectionSettings().setDatabase(\"unittest\");\n\n    try (Morphium morphium = new Morphium(cfg)) {\n        // Test code here\n        // No MongoDB required!\n    }\n}\n</code></pre>"},{"location":"inmemory-driver/#shared-driver-tests","title":"Shared Driver Tests","text":"<pre><code>@Test\npublic void testMultipleInstances() {\n    String dbName = \"shareddb\";\n\n    MorphiumConfig cfg1 = new MorphiumConfig();\n    cfg1.driverSettings().setDriverName(\"InMemDriver\");\n    cfg1.connectionSettings().setDatabase(dbName);\n\n    MorphiumConfig cfg2 = new MorphiumConfig();\n    cfg2.driverSettings().setDriverName(\"InMemDriver\");\n    cfg2.connectionSettings().setDatabase(dbName);\n\n    try (Morphium m1 = new Morphium(cfg1);\n         Morphium m2 = new Morphium(cfg2)) {\n\n        // Both share the same driver\n        // Write with m1, read with m2\n        m1.store(new MyEntity(\"test\"));\n        MyEntity found = m2.findById(MyEntity.class, id);\n\n        // Works correctly!\n    }\n}\n</code></pre>"},{"location":"inmemory-driver/#messaging-tests","title":"Messaging Tests","text":"<pre><code>@Test\npublic void testMessaging() throws Exception {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.driverSettings().setDriverName(\"InMemDriver\");\n    cfg.connectionSettings().setDatabase(\"msgtest\");\n\n    try (Morphium morphium = new Morphium(cfg)) {\n        MorphiumMessaging sender = morphium.createMessaging();\n        MorphiumMessaging receiver = morphium.createMessaging();\n\n        AtomicInteger count = new AtomicInteger(0);\n\n        receiver.addListenerForTopic(\"test\", (m, msg) -&gt; {\n            count.incrementAndGet();\n            return null;\n        });\n\n        sender.start();\n        receiver.start();\n\n        sender.sendMessage(new Msg(\"test\", \"Hello\", \"World\", 30000));\n\n        Thread.sleep(500);\n        assertEquals(1, count.get());\n    }\n}\n</code></pre>"},{"location":"inmemory-driver/#monitoring","title":"Monitoring","text":"<p>Built-in Status Monitoring: When using messaging with InMemory driver, all instances automatically respond to <code>morphium_status</code> queries. This provides JVM, messaging, and driver metrics without any setup.</p> <pre><code>MorphiumMessaging sender = morphium.createMessaging();\nsender.start();\n\n// Query status from all instances\nList&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n    new Msg(sender.getStatusInfoListenerName(), \"status\", \"ALL\"),\n    5, 2000\n);\n\n// Check metrics\nfor (Msg r : responses) {\n    Map&lt;String, Object&gt; stats = r.getMapValue();\n    System.out.println(\"Heap: \" + stats.get(\"jvm.heap.used\"));\n    System.out.println(\"Processing: \" + stats.get(\"messaging.processing\"));\n}\n</code></pre> <p>See Messaging - Built-in Status Monitoring for complete documentation.</p>"},{"location":"inmemory-driver/#best-practices","title":"Best Practices","text":"<ol> <li>Use for Unit Tests Only: Not intended for production</li> <li>Separate Database Names: Different test classes should use different database names to avoid interference</li> <li>Clean Up: Use try-with-resources to ensure proper cleanup</li> <li>Test Against Real MongoDB: Always verify behavior against actual MongoDB before production</li> <li>Watch Memory Usage: Large datasets can consume significant memory</li> </ol>"},{"location":"inmemory-driver/#troubleshooting","title":"Troubleshooting","text":""},{"location":"inmemory-driver/#issue-change-streams-not-working","title":"Issue: Change streams not working","text":"<p>Solution: Ensure you're using v6.0+ with the deep copy snapshot fix</p>"},{"location":"inmemory-driver/#issue-messages-not-received-by-all-listeners","title":"Issue: Messages not received by all listeners","text":"<p>Solution: Use database-scoped sharing by ensuring all Morphium instances use the same database name</p>"},{"location":"inmemory-driver/#issue-nullpointerexception-in-insert","title":"Issue: NullPointerException in insert()","text":"<p>Solution: Upgrade to v6.0+ which includes index data structure initialization fix</p>"},{"location":"inmemory-driver/#issue-driver-shutdown-too-early","title":"Issue: Driver shutdown too early","text":"<p>Solution: v6.0+ includes reference counting to prevent premature shutdown</p>"},{"location":"inmemory-driver/#see-also","title":"See Also","text":"<ul> <li>MorphiumServer - Standalone MongoDB-compatible server</li> <li>Messaging - Messaging patterns with InMemory driver</li> <li>Migration v5 to v6 - Upgrading to latest InMemory driver features</li> <li>Configuration Reference - Complete configuration options</li> </ul>"},{"location":"messaging/","title":"Messaging","text":"<p>Morphium provides a MongoDB\u2011backed message queue with topic\u2011based listeners.</p> <p>Concepts</p> <ul> <li>Topic: string category for messages (e.g., <code>user.created</code>)</li> <li>Exclusive vs non\u2011exclusive:</li> <li>Exclusive (<code>Msg.setExclusive(true)</code>): exactly one listener processes the message (one\u2011of\u2011n); implemented using a lock collection</li> <li>Non\u2011exclusive (default): every registered listener for the topic processes the message (broadcast)</li> <li>Answers: listeners may return a <code>Msg</code> as response; senders can wait synchronously or asynchronously</li> <li>Implementations: choose between Standard and Advanced; see Messaging Implementations for differences and migration.</li> </ul> <p>Setup <pre><code>import de.caluga.morphium.messaging.*;\n\n// Create via Morphium factory (preferred)\nMorphiumMessaging messaging = morphium.createMessaging();\n// Or with overrides: morphium.createMessaging(cfg.messagingSettings())\nmessaging.start();\n\n// Listen to a topic\nmessaging.addListenerForTopic(\"user.created\", (mm, m) -&gt; {\n  System.out.println(\"Got: \" + m.getMsg());\n  return null; // no answer\n});\n\n// Send a message\nMsg msg = new Msg(\"user.created\", \"User alice created\", \"userId:123\");\nmessaging.sendMessage(msg);\n</code></pre></p> <p>Request/Response <pre><code>// Listener answering a request\nmessaging.addListenerForTopic(\"user.lookup\", (mm, m) -&gt; {\n  var response = new Msg(m.getTopic(), \"ok\", \"\");\n  response.setMapValue(Map.of(\"userId\", m.getValue()));\n  return response;\n});\n\n// Sender waiting for first answer\nMsg req = new Msg(\"user.lookup\", \"find\", \"user123\");\nMsg resp = messaging.sendAndAwaitFirstAnswer(req, 5000);\n</code></pre></p> <p>Configuration (via <code>MessagingSettings</code>)</p> <ul> <li>Queue name: <code>setMessageQueueName(String)</code>: collection suffix used for the queue.</li> <li>Window size: <code>setMessagingWindowSize(int)</code>: number of messages processed per batch. Messaging marks up to this many messages and processes them as one window.</li> <li>Multithreading: <code>setMessagingMultithreadded(boolean)</code>: process multiple messages in parallel using (virtual) threads; <code>false</code> enforces single\u2011threaded, sequential handling.</li> <li>Change streams: <code>setUseChangeStream(boolean)</code>: use MongoDB Change Streams to get push\u2011style notifications for new messages; when <code>false</code>, messaging uses polling. Requires a replica set for Change Streams.</li> <li>Poll pause: <code>setMessagingPollPause(int)</code>: pause (in ms) between polling requests when not using Change Streams. Also used as a heartbeat to check for messages outside the current processing window (e.g., if new messages arrive and the queue holds more than <code>windowSize</code>, a poll is triggered once after this pause).</li> </ul> <p>Example <pre><code>var ms = new MessagingSettings();\nms.setMessageQueueName(\"default\");\nms.setMessagingWindowSize(100);\nms.setMessagingMultithreadded(true);\nms.setUseChangeStream(true);\nms.setMessagingPollPause(250);\n\nMorphiumMessaging mq = morphium.createMessaging(ms);\nmq.start();\n</code></pre></p> <p>Examples and behavior</p> <ul> <li>Sequential processing: <code>multithreadded=false</code>, <code>windowSize=1</code> \u2192 exactly one message is processed at a time, in order.</li> <li>Batched parallelism: <code>multithreadded=true</code>, <code>windowSize=100</code> \u2192 up to 100 messages are fetched and processed concurrently per window.</li> </ul> <p>Notes</p> <ul> <li>When Change Streams are disabled, polling respects <code>messagingPollPause</code> to reduce load but still peeks for messages beyond the current window so bursts are noticed promptly.</li> </ul>"},{"location":"messaging/#benefits-tradeoffs","title":"Benefits &amp; Trade\u2011offs","text":"<p>Benefits</p> <ul> <li>Persistent queue: messages are stored in MongoDB by default (durability across restarts); use in\u2011memory storage only when persistence is not needed.</li> <li>Queryable messages: run ad\u2011hoc queries for statistics, audits, or status checks without interfering with processing.</li> <li>Change streams: combine with MongoDB change streams to react to new messages transparently (no polling; requires replica set).</li> <li>No extra infrastructure: reuse your existing MongoDB setup\u2014no separate broker or runtime dependency when you already operate a replica set.</li> </ul> <p>Trade\u2011offs</p> <ul> <li>Throughput: slower than purpose\u2011built brokers; every message is a document write/read.</li> <li>Load: very high message rates will add notable database load\u2014plan capacity accordingly or choose a different transport when ultra\u2011high throughput is critical.</li> </ul>"},{"location":"messaging/#v60-improvements","title":"V6.0 Improvements","text":""},{"location":"messaging/#change-stream-reliability","title":"Change Stream Reliability","text":"<p>Morphium 6.0 significantly improved change stream handling in messaging:</p> <p>No More Re-reads - v5: messaging layer re-read documents after change stream events - v6: uses <code>evt.getFullDocument()</code> directly from change stream snapshots - More efficient, no dirty reads, no race conditions</p> <p>Document Snapshots <pre><code>// Change stream events now contain immutable snapshots\n// Messages are processed from the exact state at insert time\nmessaging.addListenerForTopic(\"events\", (m, msg) -&gt; {\n    // msg is from immutable snapshot, safe to process\n    // No concurrent modifications possible\n    return null;\n});\n</code></pre></p>"},{"location":"messaging/#inmemorydriver-support","title":"InMemoryDriver Support","text":"<p>Full messaging support with InMemoryDriver for testing:</p> <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.driverSettings().setDriverName(\"InMemDriver\");\ncfg.connectionSettings().setDatabase(\"testdb\");\n\ntry (Morphium morphium = new Morphium(cfg)) {\n    MorphiumMessaging sender = morphium.createMessaging();\n    MorphiumMessaging receiver = morphium.createMessaging();\n\n    receiver.addListenerForTopic(\"test\", (m, msg) -&gt; {\n        // Process message\n        return null;\n    });\n\n    sender.start();\n    receiver.start();\n\n    sender.sendMessage(new Msg(\"test\", \"Hello\", \"World\", 30000));\n}\n</code></pre> <p>Multi-Instance Support <pre><code>// Multiple Morphium instances sharing same database\nMorphium m1 = new Morphium(cfg);\nMorphium m2 = new Morphium(cfg);\n\nMorphiumMessaging msg1 = m1.createMessaging();\nMorphiumMessaging msg2 = m2.createMessaging();\n\n// Both share the same InMemoryDriver\n// Change streams work correctly\n// Exclusive messages properly distributed\n// Broadcast messages delivered to all\n</code></pre></p>"},{"location":"messaging/#virtual-threads","title":"Virtual Threads","text":"<p>Java 21 virtual threads for lightweight concurrency: - Change stream callbacks run on virtual threads - Each change stream watcher has its own virtual thread executor - Minimal memory overhead for thousands of concurrent listeners</p>"},{"location":"messaging/#built-in-status-monitoring","title":"Built-in Status Monitoring","text":"<p>Every Morphium messaging instance automatically includes a status listener that responds to queries on the <code>morphium_status</code> topic. This provides comprehensive monitoring without any configuration.</p>"},{"location":"messaging/#status-query-levels","title":"Status Query Levels","text":"<p>Send a message to the <code>morphium_status</code> topic (or use <code>messaging.getStatusInfoListenerName()</code>) with one of these levels:</p> <ul> <li><code>PING</code> - Simple health check (empty response, minimal overhead)</li> <li><code>MESSAGING_ONLY</code> - Messaging system stats only (default)</li> <li><code>MORPHIUM_ONLY</code> - Morphium cache and driver stats only</li> <li><code>ALL</code> - Complete system information (JVM, messaging, Morphium, driver)</li> </ul>"},{"location":"messaging/#basic-example","title":"Basic Example","text":"<pre><code>MorphiumMessaging sender = morphium.createMessaging();\nsender.start();\n\n// Query all instances for status\nList&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n    new Msg(sender.getStatusInfoListenerName(), \"status\", \"ALL\"),\n    10,     // Wait for up to 10 responses\n    2000    // 2 second timeout\n);\n\n// Process responses\nfor (Msg response : responses) {\n    Map&lt;String, Object&gt; stats = response.getMapValue();\n\n    System.out.println(\"=== Instance: \" + response.getSender() + \" ===\");\n\n    // JVM metrics\n    System.out.println(\"JVM Version: \" + stats.get(\"jvm.version\"));\n    System.out.println(\"Heap Used: \" + stats.get(\"jvm.heap.used\") + \" bytes\");\n    System.out.println(\"Active Threads: \" + stats.get(\"jvm.threads.active\"));\n\n    // Messaging metrics\n    System.out.println(\"Messages Processing: \" + stats.get(\"messaging.processing\"));\n    System.out.println(\"Messages In Progress: \" + stats.get(\"messaging.in_progress\"));\n    System.out.println(\"Waiting for Answers: \" + stats.get(\"messaging.waiting_for_answers\"));\n\n    // Driver metrics\n    System.out.println(\"Driver Stats: \" + stats.get(\"morphium.driver.stats\"));\n    System.out.println(\"Connections: \" + stats.get(\"morphium.driver.connections\"));\n}\n</code></pre>"},{"location":"messaging/#available-metrics","title":"Available Metrics","text":"<p>JVM Metrics (all levels except PING): - <code>jvm.version</code> - Java version - <code>jvm.free_mem</code>, <code>jvm.total_mem</code>, <code>jvm.max_mem</code> - Memory stats - <code>jvm.heap.init</code>, <code>jvm.heap.used</code>, <code>jvm.heap.committed</code>, <code>jvm.heap.max</code> - Heap memory - <code>jvm.nonheap.init</code>, <code>jvm.nonheap.used</code>, <code>jvm.nonheap.committed</code>, <code>jvm.nonheap.max</code> - Non-heap memory - <code>jvm.threads.active</code>, <code>jvm.threads.deamons</code>, <code>jvm.threads.peak</code>, <code>jvm.threads.total_started</code> - Thread stats</p> <p>Messaging Metrics (ALL or MESSAGING_ONLY): - <code>messaging.multithreadded</code> - Thread pool enabled - <code>messaging.threadpoolstats</code> - Thread pool statistics - <code>message_listeners_by_name</code> - Registered listeners - <code>messaging.changestream</code> - Change stream enabled - <code>messaging.window_size</code> - Message window size - <code>messaging.pause</code> - Poll pause duration - <code>messaging.processing</code> - Currently processing messages - <code>messaging.in_progress</code> - Messages in progress - <code>messaging.waiting_for_answers</code> - Pending responses count - <code>messaging.waiting_for_answers_total</code> - Total waiting for answers - <code>messaging.time_till_recieved</code> - Message transit time (ms)</p> <p>Morphium/Driver Metrics (ALL or MORPHIUM_ONLY): - <code>morphium.cachestats</code> - Cache statistics - <code>morphium.config</code> - Configuration properties - <code>morphium.driver.stats</code> - Driver statistics - <code>morphium.driver.connections</code> - Connection count per host - <code>morphium.driver.replicaset_status</code> - Replica set status</p>"},{"location":"messaging/#enabledisable-status-listener","title":"Enable/Disable Status Listener","text":"<p>The status listener is enabled by default but can be controlled:</p> <pre><code>MorphiumMessaging messaging = morphium.createMessaging();\nmessaging.start();\n\n// Disable status responses (for security or performance)\nmessaging.disableStatusInfoListener();\n\n// Re-enable status responses\nmessaging.enableStatusInfoListener();\n</code></pre>"},{"location":"messaging/#health-checks-and-monitoring","title":"Health Checks and Monitoring","text":"<p>Simple Health Check (PING): <pre><code>// Just check if instances are alive\nList&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n    new Msg(sender.getStatusInfoListenerName(), \"status\", \"PING\"),\n    5,      // Expected instances\n    1000    // Quick timeout\n);\n\nif (responses.size() &gt;= 5) {\n    System.out.println(\"All instances healthy\");\n} else {\n    System.out.println(\"WARNING: Only \" + responses.size() + \" instances responded\");\n}\n</code></pre></p> <p>Periodic Monitoring: <pre><code>// Monitor every 30 seconds\nScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\nscheduler.scheduleAtFixedRate(() -&gt; {\n    try {\n        List&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n            new Msg(sender.getStatusInfoListenerName(), \"status\", \"MESSAGING_ONLY\"),\n            10, 2000\n        );\n\n        for (Msg r : responses) {\n            Map&lt;String, Object&gt; stats = r.getMapValue();\n            int inProgress = (Integer) stats.get(\"messaging.in_progress\");\n\n            if (inProgress &gt; 1000) {\n                System.out.println(\"WARNING: \" + r.getSender() +\n                                 \" has \" + inProgress + \" messages in progress\");\n            }\n        }\n    } catch (Exception e) {\n        System.err.println(\"Monitoring failed: \" + e.getMessage());\n    }\n}, 0, 30, TimeUnit.SECONDS);\n</code></pre></p>"},{"location":"messaging/#cross-language-monitoring","title":"Cross-Language Monitoring","text":"<p>Status queries work from any MongoDB client since it's just messaging:</p> <p>From Python: <pre><code>from pymongo import MongoClient\nimport time\n\nclient = MongoClient('mongodb://localhost:27017/')\ncollection = client.morphium_messaging.msg\n\n# Send status query\ntimestamp = int(time.time() * 1000)\nstatus_msg = {\n    'name': 'morphium_status',\n    'msg': 'status',\n    'value': 'ALL',\n    'timestamp': timestamp,\n    'sender': 'python-monitor',\n    'msg_id': f'status-{timestamp}'\n}\ncollection.insert_one(status_msg)\n\n# Wait and collect responses\ntime.sleep(1)\nanswers = collection.find({\n    'in_answer_to': status_msg['msg_id'],\n    'timestamp': {'$gt': timestamp}\n})\n\nfor answer in answers:\n    stats = answer.get('map_value', {})\n    print(f\"Instance {answer['sender']}:\")\n    print(f\"  Heap: {stats.get('jvm.heap.used')} / {stats.get('jvm.heap.max')}\")\n    print(f\"  Processing: {stats.get('messaging.processing')}\")\n</code></pre></p>"},{"location":"messaging/#security-considerations","title":"Security Considerations","text":"<ul> <li>Disable in production if exposing sensitive JVM/configuration data is a concern</li> <li>Status responses include configuration properties which may contain sensitive information</li> <li>Consider using <code>PING</code> or <code>MESSAGING_ONLY</code> instead of <code>ALL</code> to limit exposed data</li> <li>Status listener respects the same security/authentication as other messaging</li> </ul> <p>See also</p> <ul> <li>In\u2011Memory Driver</li> <li>Messaging Implementations</li> <li>Migration Guide v5 \u2192 v6</li> </ul> <p>Notes and best practices</p> <ul> <li>No wildcard/global listeners: register explicit topics via <code>addListenerForTopic(topic, listener)</code></li> <li>Non\u2011exclusive messages are broadcast to all listeners of a topic</li> <li>For delayed/scheduled handling, add your own not\u2011before timestamp field and have the listener re\u2011queue or skip until due; <code>Msg.timestamp</code> is used for ordering, not scheduling</li> <li>For retries and DLQ, implement logic in listeners (inspect payload, track retry count, re\u2011queue or redirect to a DLQ topic)</li> <li>For distributed cache synchronization, see Caching Examples and Cache Patterns; Morphium provides <code>MessagingCacheSynchronizer</code>.</li> </ul>"},{"location":"monitoring-metrics-guide/","title":"Monitoring &amp; Metrics Guide","text":"<p>Comprehensive guide for monitoring Morphium applications with focus on DriverStats and performance metrics.</p>"},{"location":"monitoring-metrics-guide/#driverstats-core-monitoring-foundation","title":"DriverStats - Core Monitoring Foundation","text":"<p>DriverStats are essential for monitoring driver performance, especially connection pool health and issue detection. These metrics provide real-time insights into Morphium's internal state.</p>"},{"location":"monitoring-metrics-guide/#accessing-driverstats","title":"Accessing DriverStats","text":"<pre><code>// Get current driver statistics\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n// All metrics are cumulative counters or current values\nDouble connectionsInUse = stats.get(DriverStatsKey.CONNECTIONS_IN_USE);\nDouble connectionsInPool = stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\nDouble errors = stats.get(DriverStatsKey.ERRORS);\n</code></pre>"},{"location":"monitoring-metrics-guide/#complete-driverstats-reference","title":"Complete DriverStats Reference","text":""},{"location":"monitoring-metrics-guide/#connection-pool-metrics","title":"Connection Pool Metrics","text":"Metric Type Description Healthy Range <code>CONNECTIONS_IN_USE</code> Current Active connections currently borrowed &lt; 80% of max pool size <code>CONNECTIONS_IN_POOL</code> Current Available connections in pool &gt; 10% of max pool size <code>CONNECTIONS_OPENED</code> Counter Total connections opened since start Monotonic increasing <code>CONNECTIONS_CLOSED</code> Counter Total connections closed since start Should be &lt; OPENED <code>CONNECTIONS_RELEASED</code> Counter Connections returned to pool Should match borrowing patterns"},{"location":"monitoring-metrics-guide/#performance-metrics","title":"Performance Metrics","text":"Metric Type Description Monitoring Goal <code>THREADS_WAITING_FOR_CONNECTION</code> Current Threads waiting for available connection Should be 0 <code>ERRORS</code> Counter Total driver errors encountered Low and stable <code>NETWORK_ERRORS</code> Counter Network-related errors Temporary spikes only"},{"location":"monitoring-metrics-guide/#example-monitoring-implementation","title":"Example Monitoring Implementation","text":"<pre><code>@Component\n@Scheduled(fixedDelay = 60000) // Every minute\npublic class MorphiumMonitor {\n\n    private final Morphium morphium;\n    private final MeterRegistry meterRegistry; // Micrometer for metrics export\n\n    public void collectDriverStats() {\n        Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n        // Export all stats to monitoring system\n        stats.forEach((key, value) -&gt; {\n            Gauge.builder(\"morphium.driver.\" + key.name().toLowerCase())\n                 .register(meterRegistry, () -&gt; value);\n        });\n\n        // Calculate derived metrics\n        double connectionUtilization = calculateConnectionUtilization(stats);\n        double errorRate = calculateErrorRate(stats);\n\n        // Export derived metrics\n        Gauge.builder(\"morphium.connection.utilization\")\n             .register(meterRegistry, () -&gt; connectionUtilization);\n\n        Gauge.builder(\"morphium.connection.error_rate\")\n             .register(meterRegistry, () -&gt; errorRate);\n    }\n\n    private double calculateConnectionUtilization(Map&lt;DriverStatsKey, Double&gt; stats) {\n        Double inUse = stats.get(DriverStatsKey.CONNECTIONS_IN_USE);\n        Double inPool = stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\n        if (inPool == null || inPool == 0) return 0.0;\n        return inUse / inPool;\n    }\n\n    private double calculateErrorRate(Map&lt;DriverStatsKey, Double&gt; stats) {\n        Double errors = stats.get(DriverStatsKey.ERRORS);\n        Double opened = stats.get(DriverStatsKey.CONNECTIONS_OPENED);\n\n        if (opened == null || opened == 0) return 0.0;\n        return errors / opened;\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#connection-pool-health-monitoring","title":"Connection Pool Health Monitoring","text":""},{"location":"monitoring-metrics-guide/#critical-health-indicators","title":"Critical Health Indicators","text":"<p>1. Pool Utilization <pre><code>// Monitor connection pool utilization\npublic void checkPoolHealth() {\n    Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n    double utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                        stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\n    if (utilization &gt; 0.8) {\n        // CRITICAL: High utilization - may need pool scaling\n        logger.warn(\"High connection pool utilization: {}%\", utilization * 100);\n        alertManager.send(Alert.HIGH_POOL_UTILIZATION, utilization);\n    } else if (utilization &gt; 0.6) {\n        // WARNING: Moderate utilization - monitor closely\n        logger.info(\"Moderate connection pool utilization: {}%\", utilization * 100);\n    }\n}\n</code></pre></p> <p>2. Thread Starvation Detection <pre><code>public void checkThreadStarvation() {\n    Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n    Double waitingThreads = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\n\n    if (waitingThreads &gt; 0) {\n        // CRITICAL: Threads waiting for connections\n        logger.error(\"Thread starvation detected: {} threads waiting\", waitingThreads);\n        alertManager.send(Alert.THREAD_STARVATION, waitingThreads);\n\n        // Additional diagnostics\n        double utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                           stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n        logger.error(\"Current pool utilization: {}%\", utilization * 100);\n    }\n}\n</code></pre></p> <p>3. Connection Churn Analysis <pre><code>public void analyzeConnectionChurn() {\n    Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n    Double opened = stats.get(DriverStatsKey.CONNECTIONS_OPENED);\n    Double closed = stats.get(DriverStatsKey.CONNECTIONS_CLOSED);\n\n    // High churn might indicate configuration issues\n    double churnRate = closed / opened;\n\n    if (churnRate &gt; 0.5) {\n        logger.warn(\"High connection churn rate: {}% of connections are closed\", \n                   churnRate * 100);\n        // May indicate:\n        // - MaxConnectionLifetime too short\n        // - MaxConnectionIdleTime too short\n        // - Network instability\n    }\n}\n</code></pre></p>"},{"location":"monitoring-metrics-guide/#real-time-monitoring-dashboard","title":"Real-Time Monitoring Dashboard","text":""},{"location":"monitoring-metrics-guide/#grafana-dashboard-configuration","title":"Grafana Dashboard Configuration","text":"<p>DriverStats Panel Queries (Prometheus): <pre><code># Connection pool utilization\nmorphium_driver_connections_in_use / morphium_driver_connections_in_pool * 100\n\n# Error rate\nrate(morphium_driver_errors[5m])\n\n# Threads waiting for connections\nmorphium_driver_threads_waiting_for_connection\n\n# Connection opening rate\nrate(morphium_driver_connections_opened[5m])\n\n# Connection closing rate  \nrate(morphium_driver_connections_closed[5m])\n</code></pre></p>"},{"location":"monitoring-metrics-guide/#alert-rules-configuration","title":"Alert Rules Configuration","text":"<pre><code># alerting-rules.yml\ngroups:\n- name: morphium.rules\n  rules:\n  - alert: MorphiumHighConnectionUtilization\n    expr: morphium_connection_utilization &gt; 0.8\n    for: 2m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"Morphium connection pool utilization high\"\n      description: \"Connection pool is {{ $value }}% utilized\"\n\n  - alert: MorphiumThreadStarvation\n    expr: morphium_driver_threads_waiting_for_connection &gt; 0\n    for: 30s\n    labels:\n      severity: critical\n    annotations:\n      summary: \"Morphium threads waiting for connections\"\n      description: \"{{ $value }} threads are waiting for connections\"\n\n  - alert: MorphiumHighErrorRate\n    expr: rate(morphium_driver_errors[5m]) &gt; 0.1\n    for: 1m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"High Morphium driver error rate\"\n      description: \"Error rate is {{ $value }} errors/second\"\n</code></pre>"},{"location":"monitoring-metrics-guide/#application-level-metrics","title":"Application-Level Metrics","text":""},{"location":"monitoring-metrics-guide/#query-performance-monitoring","title":"Query Performance Monitoring","text":"<pre><code>@Component\npublic class QueryMetricsCollector {\n\n    private final MeterRegistry meterRegistry;\n    private final Timer queryTimer;\n\n    public QueryMetricsCollector(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        this.queryTimer = Timer.builder(\"morphium.query.duration\")\n                              .description(\"Query execution time\")\n                              .register(meterRegistry);\n    }\n\n    // Wrap queries with timing\n    public &lt;T&gt; List&lt;T&gt; timedQuery(Query&lt;T&gt; query) {\n        return queryTimer.recordCallable(() -&gt; query.asList());\n    }\n\n    // Monitor different query types\n    public &lt;T&gt; List&lt;T&gt; timedQueryWithTags(Query&lt;T&gt; query, String collection, String operation) {\n        return Timer.builder(\"morphium.query.duration\")\n                   .tag(\"collection\", collection)\n                   .tag(\"operation\", operation)\n                   .register(meterRegistry)\n                   .recordCallable(() -&gt; query.asList());\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#cache-performance-monitoring","title":"Cache Performance Monitoring","text":"<pre><code>@Component\npublic class CacheMetricsCollector {\n\n    public void collectCacheMetrics() {\n        // Note: Cache metrics depend on cache implementation\n        // This is conceptual - actual implementation may vary\n\n        MorphiumCache cache = morphium.getCache();\n\n        if (cache instanceof MorphiumCacheImpl) {\n            MorphiumCacheImpl cacheImpl = (MorphiumCacheImpl) cache;\n\n            // Collect cache statistics\n            long hits = cacheImpl.getHits();\n            long misses = cacheImpl.getMisses();\n            long evictions = cacheImpl.getEvictions();\n\n            double hitRatio = (double) hits / (hits + misses);\n\n            Gauge.builder(\"morphium.cache.hit_ratio\")\n                 .register(meterRegistry, () -&gt; hitRatio);\n\n            Counter.builder(\"morphium.cache.hits\")\n                   .register(meterRegistry)\n                   .increment(hits);\n\n            Counter.builder(\"morphium.cache.misses\")\n                   .register(meterRegistry)\n                   .increment(misses);\n        }\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#messaging-system-monitoring","title":"Messaging System Monitoring","text":""},{"location":"monitoring-metrics-guide/#message-queue-metrics","title":"Message Queue Metrics","text":"<pre><code>@Component\npublic class MessagingMetricsCollector {\n\n    private final Messaging messaging;\n\n    @Scheduled(fixedDelay = 30000)\n    public void collectMessagingMetrics() {\n        // Monitor message processing\n        // Note: Exact metrics depend on messaging implementation\n\n        // Queue depth monitoring\n        for (String topic : getActiveTopics()) {\n            long queueDepth = getQueueDepth(topic);\n\n            Gauge.builder(\"morphium.messaging.queue_depth\")\n                 .tag(\"topic\", topic)\n                 .register(meterRegistry, () -&gt; queueDepth);\n\n            if (queueDepth &gt; 1000) {\n                logger.warn(\"High queue depth for topic {}: {}\", topic, queueDepth);\n            }\n        }\n    }\n\n    // Message processing rate tracking\n    public void trackMessageProcessed(String topic, boolean success, long processingTime) {\n        Counter.builder(\"morphium.messaging.messages_processed\")\n               .tag(\"topic\", topic)\n               .tag(\"status\", success ? \"success\" : \"error\")\n               .register(meterRegistry)\n               .increment();\n\n        Timer.builder(\"morphium.messaging.processing_duration\")\n             .tag(\"topic\", topic)\n             .register(meterRegistry)\n             .record(processingTime, TimeUnit.MILLISECONDS);\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#health-checks-and-diagnostics","title":"Health Checks and Diagnostics","text":""},{"location":"monitoring-metrics-guide/#comprehensive-health-check","title":"Comprehensive Health Check","text":"<pre><code>@Component\npublic class MorphiumHealthIndicator implements HealthIndicator {\n\n    private final Morphium morphium;\n\n    @Override\n    public Health health() {\n        Health.Builder builder = new Health.Builder();\n\n        try {\n            // Test basic connectivity\n            long start = System.currentTimeMillis();\n            morphium.createQueryFor(User.class).limit(1).asList();\n            long responseTime = System.currentTimeMillis() - start;\n\n            // Get driver statistics for detailed health info\n            Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n            // Analyze connection pool health\n            double utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                               stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n            double waitingThreads = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\n\n            // Determine overall health\n            if (utilization &lt; 0.8 &amp;&amp; waitingThreads == 0 &amp;&amp; responseTime &lt; 1000) {\n                builder.status(Status.UP);\n            } else if (utilization &lt; 0.9 &amp;&amp; waitingThreads == 0 &amp;&amp; responseTime &lt; 3000) {\n                builder.status(\"DEGRADED\");\n            } else {\n                builder.status(Status.DOWN);\n            }\n\n            // Add detailed metrics\n            builder.withDetail(\"database\", Map.of(\n                \"responseTime\", responseTime + \"ms\",\n                \"status\", responseTime &lt; 3000 ? \"UP\" : \"SLOW\"\n            ));\n\n            builder.withDetail(\"connectionPool\", Map.of(\n                \"utilization\", String.format(\"%.1f%%\", utilization * 100),\n                \"connectionsInUse\", stats.get(DriverStatsKey.CONNECTIONS_IN_USE).intValue(),\n                \"connectionsInPool\", stats.get(DriverStatsKey.CONNECTIONS_IN_POOL).intValue(),\n                \"threadsWaiting\", waitingThreads.intValue(),\n                \"totalErrors\", stats.get(DriverStatsKey.ERRORS).intValue()\n            ));\n\n            return builder.build();\n\n        } catch (Exception e) {\n            return builder.status(Status.DOWN)\n                         .withException(e)\n                         .build();\n        }\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#diagnostic-information-collection","title":"Diagnostic Information Collection","text":"<pre><code>@RestController\n@RequestMapping(\"/admin/morphium\")\npublic class MorphiumDiagnosticsController {\n\n    @GetMapping(\"/stats\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getDriverStats() {\n        Map&lt;DriverStatsKey, Double&gt; rawStats = morphium.getDriver().getDriverStats();\n\n        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n        rawStats.forEach((key, value) -&gt; \n            response.put(key.name().toLowerCase(), value));\n\n        // Add derived metrics\n        response.put(\"connection_utilization\", \n            rawStats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n            rawStats.get(DriverStatsKey.CONNECTIONS_IN_POOL));\n\n        return ResponseEntity.ok(response);\n    }\n\n    @GetMapping(\"/config\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getConfiguration() {\n        MorphiumConfig config = morphium.getConfig();\n\n        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n        response.put(\"maxConnectionsPerHost\", config.connectionSettings().getMaxConnectionsPerHost());\n        response.put(\"minConnectionsPerHost\", config.connectionSettings().getMinConnectionsPerHost());\n        response.put(\"maxWaitTime\", config.connectionSettings().getMaxWaitTime());\n        response.put(\"database\", config.connectionSettings().getDatabase());\n        response.put(\"driverName\", config.driverSettings().getDriverName());\n\n        return ResponseEntity.ok(response);\n    }\n\n    @PostMapping(\"/connection-pool/analyze\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; analyzeConnectionPool() {\n        Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n        Map&lt;String, Object&gt; analysis = new HashMap&lt;&gt;();\n\n        // Connection pool analysis\n        double utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                           stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n        analysis.put(\"utilization\", utilization);\n\n        // Health assessment\n        List&lt;String&gt; issues = new ArrayList&lt;&gt;();\n        List&lt;String&gt; recommendations = new ArrayList&lt;&gt;();\n\n        if (utilization &gt; 0.8) {\n            issues.add(\"High connection pool utilization (\" + (utilization * 100) + \"%)\");\n            recommendations.add(\"Consider increasing maxConnectionsPerHost\");\n        }\n\n        if (stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION) &gt; 0) {\n            issues.add(\"Threads waiting for connections\");\n            recommendations.add(\"Increase connection pool size or optimize query performance\");\n        }\n\n        double errorRate = stats.get(DriverStatsKey.ERRORS) / \n                          stats.get(DriverStatsKey.CONNECTIONS_OPENED);\n        if (errorRate &gt; 0.05) {\n            issues.add(\"High error rate (\" + (errorRate * 100) + \"%)\");\n            recommendations.add(\"Check network stability and MongoDB health\");\n        }\n\n        analysis.put(\"issues\", issues);\n        analysis.put(\"recommendations\", recommendations);\n        analysis.put(\"healthScore\", calculateHealthScore(stats));\n\n        return ResponseEntity.ok(analysis);\n    }\n\n    private int calculateHealthScore(Map&lt;DriverStatsKey, Double&gt; stats) {\n        double utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                           stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n        double waitingThreads = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\n        double errorRate = stats.get(DriverStatsKey.ERRORS) / \n                          stats.get(DriverStatsKey.CONNECTIONS_OPENED);\n\n        int score = 100;\n\n        if (utilization &gt; 0.9) score -= 30;\n        else if (utilization &gt; 0.8) score -= 15;\n        else if (utilization &gt; 0.6) score -= 5;\n\n        if (waitingThreads &gt; 0) score -= 40;\n\n        if (errorRate &gt; 0.1) score -= 25;\n        else if (errorRate &gt; 0.05) score -= 10;\n\n        return Math.max(0, score);\n    }\n}\n</code></pre>"},{"location":"monitoring-metrics-guide/#monitoring-best-practices","title":"Monitoring Best Practices","text":""},{"location":"monitoring-metrics-guide/#1-baseline-establishment","title":"1. Baseline Establishment","text":"<ul> <li>Monitor DriverStats for 1-2 weeks to establish baseline performance</li> <li>Document normal operating ranges for each metric</li> <li>Set alert thresholds based on observed patterns</li> </ul>"},{"location":"monitoring-metrics-guide/#2-proactive-monitoring","title":"2. Proactive Monitoring","text":"<ul> <li>Connection utilization &gt; 60%: Monitor closely</li> <li>Connection utilization &gt; 80%: Plan capacity increase</li> <li>Threads waiting &gt; 0: Immediate investigation required</li> <li>Error rate &gt; 5%: Check MongoDB and network health</li> </ul>"},{"location":"monitoring-metrics-guide/#3-regular-health-checks","title":"3. Regular Health Checks","text":"<ul> <li>Automated health checks every minute</li> <li>Deep diagnostic analysis every hour</li> <li>Weekly performance trend analysis</li> </ul>"},{"location":"monitoring-metrics-guide/#4-incident-response","title":"4. Incident Response","text":"<ul> <li>Level 1: Connection utilization &gt; 90% - Scale immediately</li> <li>Level 2: Threads waiting for connections - Emergency response</li> <li>Level 3: Error rate &gt; 10% - Full system investigation</li> </ul> <p>This monitoring guide provides comprehensive coverage of Morphium's DriverStats and ensures optimal connection pool performance and early issue detection.</p>"},{"location":"morphium-server/","title":"MorphiumServer: Standalone MongoDB-Compatible Server","text":"<p>MorphiumServer is a standalone MongoDB wire protocol-compatible server built on the InMemoryDriver. It allows any MongoDB client (Java, Python, Node.js, Go, etc.) to connect and interact with an in-memory database. Important: MorphiumServer is part of the main Morphium JAR, not a separate application.</p>"},{"location":"morphium-server/#key-features","title":"Key Features","text":"<ul> <li>\u2705 MongoDB Wire Protocol Compatible - Works with any MongoDB client library</li> <li>\u2705 Multi-Language Support - Connect from Java, Python, Node.js, Go, C#, etc.</li> <li>\u2705 Fast Startup - Starts in ~100-500ms vs ~2-5 seconds for MongoDB</li> <li>\u2705 Lightweight - ~50-100MB RAM vs ~500MB-1GB for MongoDB</li> <li>\u2705 No Installation - Pure Java, runs anywhere</li> <li>\u2705 Perfect for CI/CD - No Docker or MongoDB installation required</li> <li>\u2705 Integration Testing - Test multi-language microservices together</li> </ul>"},{"location":"morphium-server/#quick-start","title":"Quick Start","text":""},{"location":"morphium-server/#running-from-command-line","title":"Running from Command Line","text":"<pre><code># Build Morphium first\nmvn clean package -DskipTests\n\n# Run MorphiumServer (default port is 17017)\njava -cp target/morphium-6.0.1-SNAPSHOT.jar \\\n     de.caluga.morphium.server.MorphiumServer \\\n     --port 27017 --host 0.0.0.0\n</code></pre>"},{"location":"morphium-server/#running-programmatically","title":"Running Programmatically","text":"<pre><code>import de.caluga.morphium.server.MorphiumServer;\n\npublic class MyApp {\n    public static void main(String[] args) throws Exception {\n        // Start embedded MongoDB-compatible server\n        MorphiumServer server = new MorphiumServer(27017, \"0.0.0.0\", 100, 10);\n        server.start();\n\n        System.out.println(\"MorphiumServer running on port 27017\");\n\n        // Keep running\n        while (true) {\n            Thread.sleep(1000);\n        }\n    }\n}\n</code></pre>"},{"location":"morphium-server/#configuration","title":"Configuration","text":""},{"location":"morphium-server/#command-line-arguments","title":"Command Line Arguments","text":"<pre><code>-p, --port &lt;number&gt;           # Server port (default: 17017)\n-h, --host &lt;address&gt;          # Bind address (default: localhost)\n-mt, --maxThreads &lt;number&gt;    # Max thread pool size (default: 1000)\n-mint, --minThreads &lt;number&gt;  # Min thread pool size (default: 10)\n-c, --compressor &lt;type&gt;       # Compression: snappy, zstd, zlib, none\n-rs, --replicaset &lt;name&gt; &lt;hosts&gt;  # Replica set mode (experimental)\n</code></pre>"},{"location":"morphium-server/#constructor-options","title":"Constructor Options","text":"<pre><code>// Full constructor\nMorphiumServer server = new MorphiumServer(\n    int port,           // Server port\n    String host,        // Bind address\n    int maxThreads,     // Maximum threads\n    int minThreads      // Minimum threads\n);\n\n// Default constructor (port 17017, localhost, 100/10 threads)\nMorphiumServer server = new MorphiumServer();\n</code></pre>"},{"location":"morphium-server/#connecting-clients","title":"Connecting Clients","text":""},{"location":"morphium-server/#java-morphium","title":"Java (Morphium)","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings()\n   .setDatabase(\"mydb\")\n   .addHost(\"localhost\", 27017);\ncfg.driverSettings()\n   .setDriverName(\"SingleMongoConnectDriver\");\n\nMorphium morphium = new Morphium(cfg);\n</code></pre>"},{"location":"morphium-server/#python-pymongo","title":"Python (PyMongo)","text":"<pre><code>from pymongo import MongoClient\n\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client.mydb\ncollection = db.users\n\n# Works like regular MongoDB!\ncollection.insert_one({'name': 'Alice', 'age': 30})\nuser = collection.find_one({'name': 'Alice'})\nprint(user)\n</code></pre>"},{"location":"morphium-server/#nodejs-mongodb-driver","title":"Node.js (mongodb driver)","text":"<pre><code>const { MongoClient } = require('mongodb');\n\nasync function main() {\n    const client = new MongoClient('mongodb://localhost:27017');\n    await client.connect();\n\n    const db = client.db('mydb');\n    const collection = db.collection('users');\n\n    await collection.insertOne({ name: 'Bob', age: 25 });\n    const user = await collection.findOne({ name: 'Bob' });\n    console.log(user);\n}\n\nmain();\n</code></pre>"},{"location":"morphium-server/#go-mongo-driver","title":"Go (mongo-driver)","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"go.mongodb.org/mongo-driver/bson\"\n    \"go.mongodb.org/mongo-driver/mongo\"\n    \"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\nfunc main() {\n    client, _ := mongo.Connect(\n        context.TODO(),\n        options.Client().ApplyURI(\"mongodb://localhost:27017\"),\n    )\n\n    collection := client.Database(\"mydb\").Collection(\"users\")\n    collection.InsertOne(context.TODO(), bson.D{{\"name\", \"Charlie\"}})\n}\n</code></pre>"},{"location":"morphium-server/#mongodb-shell","title":"MongoDB Shell","text":"<pre><code>mongosh mongodb://localhost:27017/mydb\n\n# Test it\n&gt; db.users.insertOne({name: \"Alice\", age: 30})\n&gt; db.users.find()\n</code></pre>"},{"location":"morphium-server/#use-cases","title":"Use Cases","text":""},{"location":"morphium-server/#1-cicd-pipelines","title":"1. CI/CD Pipelines","text":"<pre><code># .github/workflows/test.yml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build Morphium\n        run: mvn clean package -DskipTests\n\n      - name: Start MorphiumServer\n        run: |\n          java -cp target/morphium-6.0.1-SNAPSHOT.jar \\\n               de.caluga.morphium.server.MorphiumServer \\\n               --port 27017 --host 0.0.0.0 &amp;\n          sleep 2\n\n      - name: Run Integration Tests\n        run: npm test\n        env:\n          MONGO_URL: mongodb://localhost:27017\n</code></pre>"},{"location":"morphium-server/#2-integration-testing-multi-language","title":"2. Integration Testing (Multi-Language)","text":"<pre><code>@BeforeAll\nstatic void startServer() throws Exception {\n    server = new MorphiumServer(27017, \"0.0.0.0\", 100, 10);\n    server.start();\n    Thread.sleep(500); // Wait for server to be ready\n}\n\n@Test\nvoid testCrossLanguageCompatibility() throws Exception {\n    // Insert from Java\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.connectionSettings().setDatabase(\"test\").addHost(\"localhost\", 27017);\n    cfg.driverSettings().setDriverName(\"SingleMongoConnectDriver\");\n\n    Morphium morphium = new Morphium(cfg);\n    MyEntity entity = new MyEntity();\n    entity.setName(\"test-entity\");\n    morphium.store(entity);\n    morphium.close();\n\n    // Verify from Python script\n    ProcessBuilder pb = new ProcessBuilder(\"python3\", \"test_read.py\");\n    pb.environment().put(\"MONGO_URL\", \"mongodb://localhost:27017/test\");\n    Process p = pb.start();\n    assertEquals(0, p.waitFor());\n}\n\n@AfterAll\nstatic void stopServer() {\n    server.terminate();\n}\n</code></pre>"},{"location":"morphium-server/#3-microservices-development","title":"3. Microservices Development","text":"<pre><code># Terminal 1: Start MorphiumServer\njava -cp target/morphium-6.0.1-SNAPSHOT.jar \\\n     de.caluga.morphium.server.MorphiumServer --port 27017\n\n# Terminal 2: Start Node.js service\nMONGO_URL=mongodb://localhost:27017 npm start\n\n# Terminal 3: Start Python service\nMONGO_URL=mongodb://localhost:27017 python app.py\n\n# Terminal 4: Start Java service\nMONGO_URL=mongodb://localhost:27017 ./gradlew run\n</code></pre>"},{"location":"morphium-server/#4-docker-deployment","title":"4. Docker Deployment","text":"<p>Dockerfile: <pre><code>FROM openjdk:21-slim\nWORKDIR /app\n\n# Copy Morphium JAR\nCOPY target/morphium-6.0.1-SNAPSHOT.jar /app/\n\nEXPOSE 27017\n\nCMD [\"java\", \"-cp\", \"/app/morphium-6.0.1-SNAPSHOT.jar\", \\\n     \"de.caluga.morphium.server.MorphiumServer\", \\\n     \"--port\", \"27017\", \"--host\", \"0.0.0.0\"]\n</code></pre></p> <p>Docker Compose: <pre><code>version: '3.8'\n\nservices:\n  morphium-db:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"27017:27017\"\n\n  app:\n    image: myapp:latest\n    depends_on:\n      - morphium-db\n    environment:\n      - MONGO_URL=mongodb://morphium-db:27017/appdb\n</code></pre></p> <p>Build and Run: <pre><code>docker build -t morphium-server .\ndocker run -p 27017:27017 morphium-server\n\n# Or use docker-compose\ndocker-compose up\n</code></pre></p>"},{"location":"morphium-server/#performance","title":"Performance","text":"Metric MorphiumServer MongoDB Startup Time ~100-500ms ~2-5 seconds Memory (baseline) ~50-100MB ~500MB-1GB Inserts/sec ~50,000 Varies Queries/sec ~100,000 Varies Updates/sec ~40,000 Varies Latency (localhost) 1-5ms 1-10ms"},{"location":"morphium-server/#monitoring","title":"Monitoring","text":""},{"location":"morphium-server/#built-in-status-monitoring","title":"Built-in Status Monitoring","text":"<p>All Morphium messaging instances automatically include status monitoring via the <code>morphium_status</code> topic. This works with MorphiumServer and any Morphium messaging setup.</p> <p>Quick example: <pre><code>MorphiumMessaging sender = morphium.createMessaging();\nsender.start();\n\n// Query all instances for status\nList&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n    new Msg(sender.getStatusInfoListenerName(), \"status\", \"ALL\"),\n    5,      // Wait for up to 5 responses\n    2000    // 2 second timeout\n);\n\n// Process JVM, messaging, and driver metrics\nfor (Msg response : responses) {\n    Map&lt;String, Object&gt; stats = response.getMapValue();\n    System.out.println(\"Instance: \" + response.getSender());\n    System.out.println(\"  Heap Used: \" + stats.get(\"jvm.heap.used\"));\n    System.out.println(\"  Messages Processing: \" + stats.get(\"messaging.processing\"));\n}\n</code></pre></p> <p>For complete documentation on status monitoring, including: - All available metrics (JVM, messaging, driver) - Query levels (PING, MESSAGING_ONLY, MORPHIUM_ONLY, ALL) - Cross-language monitoring (Python, Node.js, etc.) - Health checks and periodic monitoring - Enable/disable controls</p> <p>See the Messaging - Built-in Status Monitoring section.</p>"},{"location":"morphium-server/#connection-count","title":"Connection Count","text":"<pre><code>MorphiumServer server = new MorphiumServer(27017, \"localhost\", 100, 10);\nserver.start();\n\n// Get active connections\nint connections = server.getConnectionCount();\nSystem.out.println(\"Active connections: \" + connections);\n</code></pre>"},{"location":"morphium-server/#logging","title":"Logging","text":"<pre><code># Debug logging with Logback\njava -Dlogback.configurationFile=logback.xml \\\n     -cp morphium.jar de.caluga.morphium.server.MorphiumServer \\\n     --port 27017\n\n# Simple logger\njava -Dorg.slf4j.simpleLogger.defaultLogLevel=debug \\\n     -cp morphium.jar de.caluga.morphium.server.MorphiumServer \\\n     --port 27017\n</code></pre>"},{"location":"morphium-server/#limitations","title":"Limitations","text":""},{"location":"morphium-server/#data-persistence","title":"Data Persistence","text":"<ul> <li>\u274c No Disk Storage - All data in memory, lost on restart</li> <li>\u274c No Recovery - No WAL or recovery mechanism</li> <li>\ud83d\udca1 Workaround - Implement periodic export/import</li> </ul>"},{"location":"morphium-server/#scalability","title":"Scalability","text":"<ul> <li>\u274c Single Instance - No sharding support</li> <li>\u274c No Replica Sets - Experimental support only</li> <li>\u274c Memory Bound - Dataset limited by available RAM</li> </ul>"},{"location":"morphium-server/#features","title":"Features","text":"<ul> <li>\u274c GridFS - No file storage</li> <li>\u274c Full-Text Search - Limited $text support</li> <li>\u274c Advanced Geospatial - Basic queries only</li> <li>\u274c Distributed Transactions - Single instance only</li> </ul>"},{"location":"morphium-server/#security","title":"Security","text":"<ul> <li>\u274c No TLS/SSL - Plain TCP only</li> <li>\u274c No Authentication - Not implemented</li> <li>\ud83d\udca1 Workaround - Use reverse proxy for TLS</li> </ul>"},{"location":"morphium-server/#when-not-to-use","title":"When NOT to Use","text":"<p>Avoid for: - Production data requiring persistence - Datasets exceeding available RAM (&gt;16GB) - High availability requirements - TLS/SSL compliance requirements - MongoDB Atlas features - Advanced search/geospatial features</p> <p>Use Instead: - Production: Real MongoDB with persistence - Large Datasets: MongoDB with disk storage - High Availability: MongoDB replica sets - Cloud: MongoDB Atlas</p>"},{"location":"morphium-server/#building-from-source","title":"Building from Source","text":"<pre><code>git clone https://github.com/sboesebeck/morphium.git\ncd morphium\nmvn clean package -DskipTests\n\n# The server is part of the main JAR\nls -lh target/morphium-6.0.1-SNAPSHOT.jar\n\n# Run it\njava -cp target/morphium-6.0.1-SNAPSHOT.jar \\\n     de.caluga.morphium.server.MorphiumServer \\\n     --port 27017 --host 0.0.0.0\n</code></pre>"},{"location":"morphium-server/#maven-dependency","title":"Maven Dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.caluga&lt;/groupId&gt;\n    &lt;artifactId&gt;morphium&lt;/artifactId&gt;\n    &lt;version&gt;6.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Then start programmatically: <pre><code>public static void main(String[] args) throws Exception {\n    // Option 1: Call main\n    de.caluga.morphium.server.MorphiumServer.main(\n        new String[]{\"--port\", \"27017\", \"--host\", \"0.0.0.0\"}\n    );\n\n    // Option 2: Create instance\n    MorphiumServer server = new MorphiumServer(27017, \"0.0.0.0\", 100, 10);\n    server.start();\n}\n</code></pre></p>"},{"location":"morphium-server/#comparison-morphiumserver-vs-inmemory-driver","title":"Comparison: MorphiumServer vs InMemory Driver","text":"Feature MorphiumServer InMemory Driver Network Access Yes (wire protocol) No (embedded) Multi-Language Yes No (Java only) Use Case Integration tests, microservices Unit tests Overhead Network latency In-process Setup Start server Config setting Isolation Process-level Per-JVM <p>When to use each: - InMemory Driver: Java unit tests, embedded apps - MorphiumServer: Integration tests, CI/CD, multi-language services</p>"},{"location":"morphium-server/#see-also","title":"See Also","text":"<ul> <li>InMemory Driver - Embedded driver for unit tests</li> <li>Messaging - Messaging with MorphiumServer</li> <li>Configuration Reference - All configuration options</li> <li>Architecture Overview - How it works internally</li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>Morphium combines a high\u2011performance MongoDB ODM with a built\u2011in, database\u2011native messaging system.</p> <p>Key features - Integrated messaging: topic\u2011based queue stored in MongoDB (exclusive one\u2011of\u2011n or broadcast to all listeners) - Own MongoDB wire\u2011protocol driver (no full MongoDB Java driver dependency) - Distributed caching with cache synchronization across nodes - Annotation\u2011driven mapping and validation - Fluent query API and aggregation support - Best practice: use field name enums in queries to avoid string typos and smooth migrations</p> <p>Compatibility - Java: 21+ - MongoDB: 5.0+</p> <p>Quick start <pre><code>import de.caluga.morphium.Morphium;\nimport de.caluga.morphium.MorphiumConfig;\n\n// Configure\nMorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp\");\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\n\n// Create client\nMorphium morphium = new Morphium(cfg);\n</code></pre></p> <p>First entity <pre><code>import de.caluga.morphium.annotations.*;\nimport de.caluga.morphium.driver.MorphiumId;\n\n@Entity\n@Cache(timeout = 30_000)\npublic class User {\n  @Id private MorphiumId id;\n  @Index private String username;\n  private String email;\n}\n</code></pre></p> <p>CRUD <pre><code>User u = new User();\nu.setUsername(\"alice\");\nu.setEmail(\"alice@example.com\");\nmorphium.store(u);\n\nUser found = morphium.createQueryFor(User.class)\n    .f(\"username\").eq(\"alice\")\n    .get();\n\nfound.setEmail(\"alice.new@example.com\");\nmorphium.store(found);\nmorphium.delete(found);\n</code></pre></p> <p>Next steps - See Developer Guide for configuration, mapping, queries, aggregation, caching, and extension points - See Messaging for the built\u2011in message queue - How\u2011Tos: Aggregation Examples, Caching Examples, and Cache Patterns</p> <p>Driver notes - Morphium uses its own wire\u2011protocol driver tailored to Morphium\u2019s mapping. - Limitations: no MongoDB Atlas support and no SSL/TLS connections.</p>"},{"location":"performance-scalability-guide/","title":"Performance &amp; Scalability Guide","text":"<p>Optimizing Morphium for different scale scenarios, from small applications to systems with hundreds of millions of documents.</p>"},{"location":"performance-scalability-guide/#scale-categories","title":"Scale Categories","text":""},{"location":"performance-scalability-guide/#small-scale-1m-documents-10-concurrent-users","title":"Small Scale (&lt; 1M documents, &lt; 10 concurrent users)","text":"<p>Characteristics: Single server, low concurrency, simple queries</p> <p>Recommended Configuration: <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setMaxConnectionsPerHost(10);\ncfg.connectionSettings().setMinConnectionsPerHost(2);\ncfg.cacheSettings().setGlobalCacheValidTime(60000); // 1 minute cache\n</code></pre></p>"},{"location":"performance-scalability-guide/#medium-scale-1m-100m-documents-10-100-concurrent-users","title":"Medium Scale (1M-100M documents, 10-100 concurrent users)","text":"<p>Characteristics: Replica set, moderate concurrency, mixed read/write workloads</p> <p>Recommended Configuration: <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setMaxConnectionsPerHost(50);\ncfg.connectionSettings().setMinConnectionsPerHost(10);\ncfg.connectionSettings().setMaxWaitTime(5000);\ncfg.cacheSettings().setGlobalCacheValidTime(300000); // 5 minute cache\ncfg.messagingSettings().setMessagingWindowSize(200);\ncfg.messagingSettings().setMessagingMultithreadded(true);\n</code></pre></p>"},{"location":"performance-scalability-guide/#large-scale-100m-documents-100-concurrent-users","title":"Large Scale (100M+ documents, 100+ concurrent users)","text":"<p>Characteristics: Sharded clusters, high concurrency, complex workloads</p> <p>Recommended Configuration: <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setMaxConnectionsPerHost(200);\ncfg.connectionSettings().setMinConnectionsPerHost(50);\ncfg.connectionSettings().setMaxWaitTime(3000); // Fail fast\ncfg.connectionSettings().setRetriesOnNetworkError(10);\ncfg.connectionSettings().setSleepBetweenErrorRetries(100);\ncfg.cacheSettings().setGlobalCacheValidTime(600000); // 10 minute cache\ncfg.messagingSettings().setMessagingWindowSize(500);\ncfg.messagingSettings().setMessagingMultithreadded(true);\ncfg.messagingSettings().setPollPauseTime(50); // Reduce latency\n</code></pre></p>"},{"location":"performance-scalability-guide/#connection-pool-optimization","title":"Connection Pool Optimization","text":""},{"location":"performance-scalability-guide/#pool-sizing-guidelines","title":"Pool Sizing Guidelines","text":"<p>Formula for connection pool sizing: <pre><code>MaxConnections = (Peak Concurrent Operations \u00d7 Average Operation Time) / 1000ms\n</code></pre></p> <p>Examples: - 100 ops/sec, 50ms avg operation time: 100 \u00d7 50 / 1000 = 5 connections - 1000 ops/sec, 100ms avg operation time: 1000 \u00d7 100 / 1000 = 100 connections</p>"},{"location":"performance-scalability-guide/#monitor-pool-health","title":"Monitor Pool Health","text":"<pre><code>// Regular monitoring\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\ndouble utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                    stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\nif (utilization &gt; 0.8) {\n    // Consider increasing pool size\n    System.out.println(\"WARNING: High connection pool utilization: \" + utilization);\n}\n\ndouble waitingThreads = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\nif (waitingThreads &gt; 0) {\n    System.out.println(\"WARNING: Threads waiting for connections: \" + waitingThreads);\n}\n</code></pre>"},{"location":"performance-scalability-guide/#connection-lifecycle-tuning","title":"Connection Lifecycle Tuning","text":"<pre><code>// For high-throughput systems\ncfg.connectionSettings().setMaxConnectionIdleTime(300000); // 5 minutes\ncfg.connectionSettings().setMaxConnectionLifetime(1800000); // 30 minutes\n\n// For low-latency systems\ncfg.connectionSettings().setMaxConnectionIdleTime(60000);  // 1 minute\ncfg.connectionSettings().setMaxConnectionLifetime(600000); // 10 minutes\n</code></pre>"},{"location":"performance-scalability-guide/#query-performance-optimization","title":"Query Performance Optimization","text":""},{"location":"performance-scalability-guide/#index-strategy","title":"Index Strategy","text":"<p>1. Single Field Indexes <pre><code>@Entity\npublic class User {\n    @Index\n    private String email;      // Unique lookups\n\n    @Index\n    private String status;     // Filter queries\n\n    @Index\n    private Date lastLogin;    // Range queries\n}\n</code></pre></p> <p>2. Compound Indexes <pre><code>@Entity\n@Index({\"status\", \"lastLogin\"})        // Filter + sort\n@Index({\"userId\", \"timestamp\"})        // User timeline queries\n@Index({\"category\", \"priority\", \"-created\"}) // Multi-field filtering\npublic class Task {\n    // Fields...\n}\n</code></pre></p> <p>3. Index for Large Collections For collections with 100M+ documents: <pre><code>@Entity\n@Index({\"partitionKey\", \"queryField\"})  // Partition-aware indexing\n@Index({\"timestamp:1\"})                 // Time-based partitioning\npublic class LogEntry {\n    private String partitionKey; // e.g., date-based partition\n    private Date timestamp;\n    // Other fields...\n}\n</code></pre></p>"},{"location":"performance-scalability-guide/#query-patterns","title":"Query Patterns","text":"<p>Efficient Queries: <pre><code>// Good: Uses index, specific criteria\nQuery&lt;User&gt; q = morphium.createQueryFor(User.class)\n    .f(\"status\").eq(\"active\")\n    .f(\"lastLogin\").gte(cutoffDate)\n    .limit(100);\n\n// Good: Projection reduces data transfer\nQuery&lt;User&gt; q = morphium.createQueryFor(User.class)\n    .f(\"email\").eq(\"user@example.com\")\n    .project(\"name\", \"email\", \"status\");\n</code></pre></p> <p>Avoid These Patterns: <pre><code>// Bad: No index usage\nQuery&lt;User&gt; q = morphium.createQueryFor(User.class)\n    .f(\"description\").matches(\".*keyword.*\"); // Regex without index\n\n// Bad: Large result sets without pagination\nList&lt;User&gt; allUsers = morphium.createQueryFor(User.class).asList(); // Millions of records\n</code></pre></p>"},{"location":"performance-scalability-guide/#large-result-set-handling","title":"Large Result Set Handling","text":"<pre><code>// Use iterator for large datasets\nMorphiumIterator&lt;LogEntry&gt; iterator = morphium.createQueryFor(LogEntry.class)\n    .f(\"timestamp\").gte(startDate)\n    .f(\"timestamp\").lt(endDate)\n    .asIterable(1000); // Process in batches of 1000\n\nwhile (iterator.hasNext()) {\n    LogEntry entry = iterator.next();\n    processEntry(entry); // Process one at a time\n\n    // Optional: Track progress\n    if (iterator.getCursor() % 10000 == 0) {\n        System.out.println(\"Processed: \" + iterator.getCursor() + \"/\" + iterator.getCount());\n    }\n}\n</code></pre>"},{"location":"performance-scalability-guide/#caching-strategy","title":"Caching Strategy","text":""},{"location":"performance-scalability-guide/#cache-configuration-by-use-case","title":"Cache Configuration by Use Case","text":"<p>High-Read, Low-Write (Reference Data): <pre><code>@Entity\n@Cache(timeout = 3600000, maxEntries = 50000, // 1 hour cache, large capacity\n       strategy = Cache.ClearStrategy.LRU,\n       syncCache = Cache.SyncCacheStrategy.CLEAR_TYPE_CACHE)\npublic class Country {\n    // Rarely changing reference data\n}\n</code></pre></p> <p>Medium-Read, Medium-Write (User Data): <pre><code>@Entity\n@Cache(timeout = 300000, maxEntries = 10000,  // 5 minute cache\n       strategy = Cache.ClearStrategy.LRU,\n       syncCache = Cache.SyncCacheStrategy.UPDATE_ENTRY)\npublic class UserProfile {\n    // User profile data with moderate changes\n}\n</code></pre></p> <p>High-Write, Low-Read (Logging Data): <pre><code>@Entity\n@NoCache // No caching for write-heavy data\n@WriteBuffer(size = 5000, timeout = 10000,\n             strategy = WriteBuffer.STRATEGY.WRITE_OLD)\npublic class AuditLog {\n    // High-frequency writes, infrequent reads\n}\n</code></pre></p>"},{"location":"performance-scalability-guide/#cache-monitoring","title":"Cache Monitoring","text":"<pre><code>// Monitor cache effectiveness\nMorphiumCache cache = morphium.getCache();\nCacheStats stats = cache.getStats();\n\ndouble hitRatio = stats.getHits() / (double)(stats.getHits() + stats.getMisses());\nSystem.out.println(\"Cache hit ratio: \" + hitRatio);\n\nif (hitRatio &lt; 0.7) {\n    System.out.println(\"WARNING: Low cache hit ratio, consider tuning cache settings\");\n}\n</code></pre>"},{"location":"performance-scalability-guide/#messaging-system-performance","title":"Messaging System Performance","text":""},{"location":"performance-scalability-guide/#high-throughput-messaging","title":"High-Throughput Messaging","text":"<pre><code>// Configuration for high message volume\ncfg.messagingSettings().setMessagingWindowSize(1000);     // Large batch size\ncfg.messagingSettings().setMessagingMultithreadded(true); // Parallel processing\ncfg.messagingSettings().setPollPauseTime(10);             // Aggressive polling\ncfg.messagingSettings().setUseChangeStream(true);         // Real-time processing\n</code></pre>"},{"location":"performance-scalability-guide/#message-processing-patterns","title":"Message Processing Patterns","text":"<p>Batch Processing: <pre><code>messaging.addListenerForTopic(\"bulk-process\", (morphiumMessaging, msg) -&gt; {\n    // Process multiple items in one message\n    List&lt;String&gt; itemIds = (List&lt;String&gt;) msg.getMapValue().get(\"itemIds\");\n    processBatch(itemIds);\n    return null;\n});\n</code></pre></p> <p>Load Balancing: <pre><code>// Exclusive processing for load distribution\nMsg msg = new Msg(\"work-queue\", \"process-item\", itemId);\nmsg.setExclusive(true); // Only one worker processes this message\nmessaging.sendMessage(msg);\n</code></pre></p>"},{"location":"performance-scalability-guide/#memory-management","title":"Memory Management","text":""},{"location":"performance-scalability-guide/#jvm-configuration-for-different-scales","title":"JVM Configuration for Different Scales","text":"<p>Small Scale: <pre><code>-Xms512m -Xmx2g\n-XX:+UseG1GC\n</code></pre></p> <p>Medium Scale: <pre><code>-Xms2g -Xmx8g\n-XX:+UseG1GC\n-XX:MaxGCPauseMillis=200\n-XX:G1HeapRegionSize=16m\n</code></pre></p> <p>Large Scale: <pre><code>-Xms8g -Xmx32g\n-XX:+UseG1GC\n-XX:MaxGCPauseMillis=100\n-XX:G1HeapRegionSize=32m\n-XX:+UnlockExperimentalVMOptions\n-XX:+UseJVMCICompiler\n</code></pre></p>"},{"location":"performance-scalability-guide/#memory-efficient-patterns","title":"Memory-Efficient Patterns","text":"<pre><code>// Use projections to reduce memory usage\nQuery&lt;User&gt; q = morphium.createQueryFor(User.class)\n    .project(\"id\", \"name\", \"email\"); // Only load needed fields\n\n// Process large datasets with iterators\nMorphiumIterator&lt;Record&gt; iter = query.asIterable(500, 5); // 500 per batch, 5 batches ahead\n</code></pre>"},{"location":"performance-scalability-guide/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"performance-scalability-guide/#key-performance-indicators","title":"Key Performance Indicators","text":"<p>System Level: <pre><code>// Monitor regularly (every minute)\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n// Connection health\ndouble connectionUtilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                              stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\n// Error rates\ndouble errorRate = stats.get(DriverStatsKey.ERRORS) / \n                  stats.get(DriverStatsKey.CONNECTIONS_OPENED);\n\n// System capacity\ndouble waitingThreads = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\n</code></pre></p>"},{"location":"performance-scalability-guide/#performance-benchmarking","title":"Performance Benchmarking","text":"<p>Simple Benchmark Template: <pre><code>public class MorphiumBenchmark {\n    public void benchmarkWrites(int count) {\n        long start = System.currentTimeMillis();\n\n        List&lt;TestEntity&gt; batch = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; count; i++) {\n            TestEntity entity = new TestEntity();\n            entity.setValue(\"Test value \" + i);\n            batch.add(entity);\n\n            if (batch.size() == 1000) {\n                morphium.storeList(batch);\n                batch.clear();\n            }\n        }\n\n        if (!batch.isEmpty()) {\n            morphium.storeList(batch);\n        }\n\n        long duration = System.currentTimeMillis() - start;\n        System.out.println(\"Wrote \" + count + \" records in \" + duration + \"ms\");\n        System.out.println(\"Rate: \" + (count * 1000 / duration) + \" records/sec\");\n    }\n}\n</code></pre></p>"},{"location":"performance-scalability-guide/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"performance-scalability-guide/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>1. Collection Partitioning <pre><code>// Time-based partitioning\n@Entity(nameProvider = MonthlyPartitionProvider.class)\npublic class LogEntry {\n    private Date timestamp;\n    // Stored in collections like: log_entry_202412, log_entry_202501, etc.\n}\n\n// Hash-based partitioning\n@Entity(nameProvider = HashPartitionProvider.class)\npublic class UserData {\n    private String userId; // Partition key\n    // Distributed across multiple collections based on hash\n}\n</code></pre></p> <p>2. Read Replicas <pre><code>// Configure read preference for scaling reads\nQuery&lt;User&gt; readQuery = morphium.createQueryFor(User.class)\n    .setReadPreferenceLevel(ReadPreferenceType.SECONDARY_PREFERRED);\n</code></pre></p>"},{"location":"performance-scalability-guide/#vertical-scaling","title":"Vertical Scaling","text":"<p>Connection Pool Scaling: <pre><code>// Scale with server capacity\nint cpuCores = Runtime.getRuntime().availableProcessors();\nint maxConnections = Math.max(50, cpuCores * 10); // 10 connections per core\n\ncfg.connectionSettings().setMaxConnectionsPerHost(maxConnections);\ncfg.connectionSettings().setMinConnectionsPerHost(maxConnections / 4);\n</code></pre></p>"},{"location":"performance-scalability-guide/#performance-testing","title":"Performance Testing","text":""},{"location":"performance-scalability-guide/#load-testing-template","title":"Load Testing Template","text":"<pre><code>public class LoadTest {\n    private final ExecutorService executor = Executors.newFixedThreadPool(20);\n\n    public void runLoadTest(int totalOperations, int concurrency) {\n        CountDownLatch latch = new CountDownLatch(concurrency);\n        AtomicInteger operations = new AtomicInteger(totalOperations);\n\n        for (int i = 0; i &lt; concurrency; i++) {\n            executor.submit(() -&gt; {\n                try {\n                    while (operations.decrementAndGet() &gt;= 0) {\n                        // Perform operation (read/write/query)\n                        performOperation();\n                    }\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n\n        latch.await();\n    }\n}\n</code></pre>"},{"location":"performance-scalability-guide/#performance-regression-testing","title":"Performance Regression Testing","text":"<pre><code>// Include in CI/CD pipeline\n@Test\npublic void performanceRegressionTest() {\n    long start = System.currentTimeMillis();\n\n    // Run standard operations\n    runStandardWorkload();\n\n    long duration = System.currentTimeMillis() - start;\n\n    // Assert performance hasn't degraded\n    assertTrue(\"Performance regression detected\", duration &lt; BASELINE_TIME * 1.2);\n}\n</code></pre> <p>This guide provides concrete strategies for scaling Morphium from small applications to systems handling hundreds of millions of documents, with specific configurations and monitoring approaches for each scale.</p>"},{"location":"production-deployment-guide/","title":"Production Deployment Guide","text":"<p>Comprehensive guide for deploying Morphium applications in production environments.</p>"},{"location":"production-deployment-guide/#performance-baseline","title":"Performance Baseline","text":"<p>Morphium Performance Advantage: - At least 10% faster than standard MongoDB Java driver with mapping - Performance advantage comes from:   - Custom wire protocol implementation optimized for Morphium's mapping   - Reduced object creation overhead   - Optimized BSON serialization/deserialization   - Connection pool efficiency</p>"},{"location":"production-deployment-guide/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":""},{"location":"production-deployment-guide/#1-configuration-review","title":"1. Configuration Review","text":"<p>Connection Pool Sizing: <pre><code>// Standard recommendation: 10-100 connections for most scenarios\ncfg.connectionSettings().setMaxConnectionsPerHost(50);  // Sweet spot for most loads\ncfg.connectionSettings().setMinConnectionsPerHost(10);  // Maintain baseline\n</code></pre></p> <p>Performance Testing Validation: <pre><code>// Verify your specific load requirements\nMorphiumConfig cfg = new MorphiumConfig();\n\n// Start conservative, monitor, and adjust\ncfg.connectionSettings().setMaxConnectionsPerHost(25);\ncfg.connectionSettings().setMinConnectionsPerHost(5);\ncfg.connectionSettings().setMaxWaitTime(5000); // Fail fast to detect issues\n\n// Monitor and adjust based on actual load:\n// - CPU utilization &lt; 70%\n// - No threads waiting for connections\n// - Response times within SLA\n</code></pre></p>"},{"location":"production-deployment-guide/#2-security-configuration","title":"2. Security Configuration","text":"<p>Authentication Setup: <pre><code>cfg.authSettings().setMongoLogin(System.getenv(\"MONGO_USERNAME\"));\ncfg.authSettings().setMongoPassword(System.getenv(\"MONGO_PASSWORD\"));\n\n// For replica set operations (if needed)\ncfg.authSettings().setMongoAdminUser(System.getenv(\"MONGO_ADMIN_USER\"));\ncfg.authSettings().setMongoAdminPwd(System.getenv(\"MONGO_ADMIN_PWD\"));\n</code></pre></p> <p>Network Security: <pre><code>// Note: Wire protocol driver has limitations\n// - No MongoDB Atlas support\n// - No SSL/TLS connections\n// Deploy in trusted network environments or use network-level encryption\n</code></pre></p>"},{"location":"production-deployment-guide/#3-environment-specific-configurations","title":"3. Environment-Specific Configurations","text":""},{"location":"production-deployment-guide/#development-environment","title":"Development Environment","text":"<pre><code>MorphiumConfig createDevConfig() {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.connectionSettings().setDatabase(\"myapp_dev\");\n    cfg.clusterSettings().addHostToSeed(\"dev-mongo\", 27017);\n    cfg.connectionSettings().setMaxConnectionsPerHost(10);  // Lower for dev\n    cfg.cacheSettings().setGlobalCacheValidTime(30000);     // Shorter cache for dev\n    // Debug logging configured via log4j2.xml\n    return cfg;\n}\n</code></pre>"},{"location":"production-deployment-guide/#staging-environment","title":"Staging Environment","text":"<pre><code>MorphiumConfig createStagingConfig() {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.connectionSettings().setDatabase(\"myapp_staging\");\n    cfg.clusterSettings().addHostToSeed(\"staging-mongo1\", 27017);\n    cfg.clusterSettings().addHostToSeed(\"staging-mongo2\", 27017);\n    cfg.connectionSettings().setMaxConnectionsPerHost(25);  // Moderate load\n    cfg.connectionSettings().setRetriesOnNetworkError(5);\n    cfg.authSettings().setMongoLogin(System.getenv(\"MONGO_USERNAME\"));\n    cfg.authSettings().setMongoPassword(System.getenv(\"MONGO_PASSWORD\"));\n    return cfg;\n}\n</code></pre>"},{"location":"production-deployment-guide/#production-environment","title":"Production Environment","text":"<pre><code>MorphiumConfig createProductionConfig() {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.connectionSettings().setDatabase(\"myapp_prod\");\n\n    // Full replica set configuration\n    cfg.clusterSettings().addHostToSeed(\"prod-mongo1\", 27017);\n    cfg.clusterSettings().addHostToSeed(\"prod-mongo2\", 27017);\n    cfg.clusterSettings().addHostToSeed(\"prod-mongo3\", 27017);\n    cfg.clusterSettings().setReplicaSetName(\"prod-replica-set\");\n\n    // Production-tuned connection pool\n    cfg.connectionSettings().setMaxConnectionsPerHost(50);\n    cfg.connectionSettings().setMinConnectionsPerHost(10);\n    cfg.connectionSettings().setMaxWaitTime(3000); // Fail fast\n    cfg.connectionSettings().setRetriesOnNetworkError(10);\n    cfg.connectionSettings().setSleepBetweenErrorRetries(200);\n\n    // Longer connection lifecycles for stability\n    cfg.connectionSettings().setMaxConnectionIdleTime(300000);  // 5 minutes\n    cfg.connectionSettings().setMaxConnectionLifetime(1800000); // 30 minutes\n\n    // Production cache settings\n    cfg.cacheSettings().setGlobalCacheValidTime(300000); // 5 minute default cache\n\n    // Messaging optimization\n    cfg.messagingSettings().setMessagingWindowSize(200);\n    cfg.messagingSettings().setMessagingMultithreadded(true);\n    cfg.messagingSettings().setUseChangeStream(true);\n\n    // Security\n    cfg.authSettings().setMongoLogin(System.getenv(\"MONGO_USERNAME\"));\n    cfg.authSettings().setMongoPassword(System.getenv(\"MONGO_PASSWORD\"));\n\n    // Note: Logging is configured via Log4j configuration files, not programmatically\n\n    return cfg;\n}\n</code></pre>"},{"location":"production-deployment-guide/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"production-deployment-guide/#1-container-deployment-docker","title":"1. Container Deployment (Docker)","text":"<p>Dockerfile: <pre><code>FROM openjdk:21-jdk-slim\n\n# Application setup\nWORKDIR /app\nCOPY target/myapp.jar app.jar\nCOPY config/morphium-prod.properties morphium.properties\n\n# JVM optimization for containers\nENV JAVA_OPTS=\"-Xms2g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200\"\n\n# Health check endpoint\nHEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \\\n  CMD curl -f http://localhost:8080/health || exit 1\n\nEXPOSE 8080\nCMD java $JAVA_OPTS -jar app.jar\n</code></pre></p> <p>Docker Compose with MongoDB: <pre><code>version: '3.8'\nservices:\n  mongodb:\n    image: mongo:7.0\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ADMIN_PASSWORD}\n    volumes:\n      - mongodb_data:/data/db\n    ports:\n      - \"27017:27017\"\n\n  app:\n    build: .\n    restart: always\n    environment:\n      MONGO_USERNAME: ${MONGO_USERNAME}\n      MONGO_PASSWORD: ${MONGO_PASSWORD}\n      JAVA_OPTS: \"-Xms2g -Xmx4g -XX:+UseG1GC\"\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - mongodb\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\nvolumes:\n  mongodb_data:\n</code></pre></p>"},{"location":"production-deployment-guide/#2-kubernetes-deployment","title":"2. Kubernetes Deployment","text":"<p>ConfigMap for Configuration: <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: morphium-config\ndata:\n  morphium.properties: |\n    database=myapp_prod\n    hosts=mongo-0.mongo,mongo-1.mongo,mongo-2.mongo\n    replica_set_name=rs0\n    max_connections_per_host=50\n    min_connections_per_host=10\n    max_wait_time=3000\n    retries_on_network_error=10\n    global_cache_valid_time=300000\n</code></pre></p> <p>Deployment: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: MONGO_USERNAME\n          valueFrom:\n            secretKeyRef:\n              name: mongo-secret\n              key: username\n        - name: MONGO_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mongo-secret\n              key: password\n        - name: JAVA_OPTS\n          value: \"-Xms2g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200\"\n        volumeMounts:\n        - name: config\n          mountPath: /app/config\n        resources:\n          limits:\n            memory: \"5Gi\"\n            cpu: \"2000m\"\n          requests:\n            memory: \"2Gi\"\n            cpu: \"1000m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 60\n          periodSeconds: 30\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n      volumes:\n      - name: config\n        configMap:\n          name: morphium-config\n</code></pre></p>"},{"location":"production-deployment-guide/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"production-deployment-guide/#1-application-metrics","title":"1. Application Metrics","text":"<p>Health Check Implementation: <pre><code>@RestController\npublic class HealthController {\n\n    @Autowired\n    private Morphium morphium;\n\n    @GetMapping(\"/health\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; health() {\n        Map&lt;String, Object&gt; health = new HashMap&lt;&gt;();\n\n        try {\n            // Test database connectivity\n            long start = System.currentTimeMillis();\n            morphium.createQueryFor(User.class).limit(1).asList();\n            long responseTime = System.currentTimeMillis() - start;\n\n            // Get driver statistics\n            Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n            health.put(\"status\", \"UP\");\n            health.put(\"database\", Map.of(\n                \"status\", \"UP\",\n                \"responseTime\", responseTime + \"ms\"\n            ));\n            health.put(\"connectionPool\", Map.of(\n                \"connectionsInUse\", stats.get(DriverStatsKey.CONNECTIONS_IN_USE).intValue(),\n                \"connectionsInPool\", stats.get(DriverStatsKey.CONNECTIONS_IN_POOL).intValue(),\n                \"threadsWaiting\", stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION).intValue(),\n                \"errors\", stats.get(DriverStatsKey.ERRORS).intValue()\n            ));\n\n            return ResponseEntity.ok(health);\n\n        } catch (Exception e) {\n            health.put(\"status\", \"DOWN\");\n            health.put(\"error\", e.getMessage());\n            return ResponseEntity.status(503).body(health);\n        }\n    }\n\n    @GetMapping(\"/metrics\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; metrics() {\n        Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n        Map&lt;String, Object&gt; metrics = new HashMap&lt;&gt;();\n        stats.forEach((key, value) -&gt; \n            metrics.put(key.name().toLowerCase(), value));\n\n        return ResponseEntity.ok(metrics);\n    }\n}\n</code></pre></p>"},{"location":"production-deployment-guide/#2-logging-configuration","title":"2. Logging Configuration","text":"<p>Production Logging Configuration (log4j2.xml): <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration status=\"WARN\"&gt;\n    &lt;Appenders&gt;\n        &lt;File name=\"MorphiumLog\" fileName=\"/var/log/myapp/morphium.log\"&gt;\n            &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss} [%level] %logger{36} - %msg%n\"/&gt;\n        &lt;/File&gt;\n        &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt;\n            &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%level] %logger{36} - %msg%n\"/&gt;\n        &lt;/Console&gt;\n    &lt;/Appenders&gt;\n\n    &lt;Loggers&gt;\n        &lt;!-- Morphium package logging --&gt;\n        &lt;Logger name=\"de.caluga.morphium\" level=\"WARN\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;!-- Driver-specific logging for troubleshooting --&gt;\n        &lt;Logger name=\"de.caluga.morphium.driver.wire.PooledDriver\" level=\"INFO\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;!-- Messaging logging --&gt;\n        &lt;Logger name=\"de.caluga.morphium.messaging\" level=\"INFO\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;Root level=\"INFO\"&gt;\n            &lt;AppenderRef ref=\"Console\"/&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre></p> <p>Log Rotation Configuration (logrotate): <pre><code>/var/log/myapp/morphium.log {\n    daily\n    rotate 30\n    compress\n    delaycompress\n    missingok\n    create 0644 app app\n    postrotate\n        systemctl reload myapp || true\n    endscript\n}\n</code></pre></p>"},{"location":"production-deployment-guide/#3-alerting-rules","title":"3. Alerting Rules","text":"<p>Connection Pool Alerts: <pre><code>// Monitor connection pool utilization\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\ndouble utilization = stats.get(DriverStatsKey.CONNECTIONS_IN_USE) / \n                    stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\nif (utilization &gt; 0.8) {\n    // Alert: High connection pool utilization\n    alertManager.send(\"HIGH_CONNECTION_POOL_UTILIZATION\", \n                     \"Connection pool \" + (utilization * 100) + \"% full\");\n}\n\nif (stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION) &gt; 0) {\n    // Alert: Thread starvation\n    alertManager.send(\"THREAD_STARVATION\", \n                     \"Threads waiting for connections: \" + \n                     stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION));\n}\n\ndouble errorRate = stats.get(DriverStatsKey.ERRORS) / \n                  stats.get(DriverStatsKey.CONNECTIONS_OPENED);\nif (errorRate &gt; 0.05) {\n    // Alert: High error rate\n    alertManager.send(\"HIGH_ERROR_RATE\", \n                     \"Connection error rate: \" + (errorRate * 100) + \"%\");\n}\n</code></pre></p>"},{"location":"production-deployment-guide/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"production-deployment-guide/#1-database-backup-strategy","title":"1. Database Backup Strategy","text":"<p>MongoDB Backup (using mongodump): <pre><code>#!/bin/bash\n# backup-script.sh\n\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_DIR=\"/backups/mongodb\"\nDATABASE=\"myapp_prod\"\n\n# Create backup\nmongodump --host rs0/mongo1:27017,mongo2:27017,mongo3:27017 \\\n          --db $DATABASE \\\n          --out $BACKUP_DIR/$DATE \\\n          --username $MONGO_USERNAME \\\n          --password $MONGO_PASSWORD\n\n# Compress backup\ntar -czf $BACKUP_DIR/backup_${DATABASE}_${DATE}.tar.gz -C $BACKUP_DIR $DATE\nrm -rf $BACKUP_DIR/$DATE\n\n# Cleanup old backups (keep 30 days)\nfind $BACKUP_DIR -name \"backup_${DATABASE}_*.tar.gz\" -mtime +30 -delete\n\necho \"Backup completed: backup_${DATABASE}_${DATE}.tar.gz\"\n</code></pre></p>"},{"location":"production-deployment-guide/#2-message-queue-backup","title":"2. Message Queue Backup","text":"<p>Since messaging uses MongoDB collections: <pre><code>#!/bin/bash\n# Include message collections in backup\n\nmongodump --host rs0/mongo1:27017,mongo2:27017,mongo3:27017 \\\n          --db myapp_prod \\\n          --collection msg_queue \\\n          --collection msg_queue_locks \\\n          --out /backups/messaging/$(date +%Y%m%d_%H%M%S)\n</code></pre></p>"},{"location":"production-deployment-guide/#3-disaster-recovery-procedures","title":"3. Disaster Recovery Procedures","text":"<p>Recovery Checklist: 1. Restore MongoDB data from latest backup 2. Verify replica set status and elect primary 3. Update application configuration if needed 4. Start application services 5. Verify connectivity and basic operations 6. Monitor for any issues</p> <p>Recovery Script: <pre><code>#!/bin/bash\n# disaster-recovery.sh\n\nBACKUP_FILE=$1\nDATABASE=\"myapp_prod\"\n\nif [ -z \"$BACKUP_FILE\" ]; then\n    echo \"Usage: $0 &lt;backup_file.tar.gz&gt;\"\n    exit 1\nfi\n\n# Extract backup\nTEMP_DIR=$(mktemp -d)\ntar -xzf $BACKUP_FILE -C $TEMP_DIR\n\n# Stop application\nkubectl scale deployment myapp --replicas=0\n\n# Restore database\nmongorestore --host rs0/mongo1:27017,mongo2:27017,mongo3:27017 \\\n             --db $DATABASE \\\n             --drop \\\n             --dir $TEMP_DIR/myapp_prod \\\n             --username $MONGO_USERNAME \\\n             --password $MONGO_PASSWORD\n\n# Verify replica set status\nmongo --host mongo1:27017 --eval \"rs.status()\"\n\n# Restart application\nkubectl scale deployment myapp --replicas=3\n\n# Cleanup\nrm -rf $TEMP_DIR\n\necho \"Recovery completed. Monitor application logs for issues.\"\n</code></pre></p>"},{"location":"production-deployment-guide/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"production-deployment-guide/#1-key-metrics-to-track","title":"1. Key Metrics to Track","text":"<p>Application Level: <pre><code>// Connection pool metrics\n- connections_in_use / connections_in_pool (target: &lt; 0.8)\n- threads_waiting_for_connection (target: 0)\n- connection_errors (target: &lt; 5% of total)\n\n// Performance metrics\n- average_response_time (target: &lt; SLA requirements)\n- throughput (ops/second)\n- cache_hit_ratio (target: &gt; 0.7 for cached entities)\n</code></pre></p> <p>System Level: <pre><code># Monitor these system metrics\n- CPU utilization (target: &lt; 70%)\n- Memory usage (target: &lt; 80%)\n- Network I/O\n- Disk I/O and space\n</code></pre></p>"},{"location":"production-deployment-guide/#2-performance-testing-in-production","title":"2. Performance Testing in Production","text":"<p>Canary Deployment Testing: <pre><code>// Gradual rollout with performance monitoring\n// Deploy to 5% of traffic, monitor metrics, then expand\n\n@Component\npublic class PerformanceMonitor {\n\n    private final MeterRegistry meterRegistry;\n\n    @EventListener\n    public void onQueryExecution(QueryExecutionEvent event) {\n        Timer.Sample sample = Timer.start(meterRegistry);\n        sample.stop(Timer.builder(\"morphium.query.duration\")\n                   .tag(\"collection\", event.getCollection())\n                   .register(meterRegistry));\n    }\n}\n</code></pre></p>"},{"location":"production-deployment-guide/#troubleshooting-common-production-issues","title":"Troubleshooting Common Production Issues","text":""},{"location":"production-deployment-guide/#issue-connection-pool-exhaustion","title":"Issue: Connection Pool Exhaustion","text":"<p>Symptoms: Timeouts, high response times Solution: <pre><code>// Immediate: Increase pool size\ncfg.connectionSettings().setMaxConnectionsPerHost(100);\n\n// Long-term: Optimize query patterns and add caching\n</code></pre></p>"},{"location":"production-deployment-guide/#issue-memory-leaks","title":"Issue: Memory Leaks","text":"<p>Symptoms: Gradual memory increase, OOM errors Solution: <pre><code>// Add connection lifecycle limits\ncfg.connectionSettings().setMaxConnectionLifetime(600000); // 10 minutes\ncfg.connectionSettings().setMaxConnectionIdleTime(180000); // 3 minutes\n\n// Review cache sizes\n@Cache(maxEntries = 5000, timeout = 300000) // Bounded cache\n</code></pre></p>"},{"location":"production-deployment-guide/#issue-network-partitions","title":"Issue: Network Partitions","text":"<p>Symptoms: Intermittent connection failures Solution: <pre><code>// Increase retry tolerance\ncfg.connectionSettings().setRetriesOnNetworkError(15);\ncfg.connectionSettings().setSleepBetweenErrorRetries(500);\ncfg.clusterSettings().setServerSelectionTimeout(10000);\n</code></pre></p> <p>This comprehensive deployment guide covers the essential aspects of running Morphium in production, from initial configuration to ongoing monitoring and maintenance.</p>"},{"location":"security-guide/","title":"Security Guide","text":"<p>Security considerations and best practices for Morphium applications in MongoDB Community Edition environments.</p>"},{"location":"security-guide/#security-model-overview","title":"Security Model Overview","text":"<p>Morphium is built primarily for MongoDB Community Edition, which has specific security limitations compared to MongoDB Enterprise. Understanding these constraints is essential for proper security planning.</p>"},{"location":"security-guide/#community-edition-limitations","title":"Community Edition Limitations","text":"<p>No SSL/TLS Support: - MongoDB Community Edition does not support SSL/TLS encryption - Morphium's wire protocol driver does not implement SSL/TLS - All network communication is unencrypted</p> <p>Basic Authentication Only: - Only username/password authentication supported - No support for:   - LDAP authentication   - Kerberos authentication   - x.509 certificate authentication   - SCRAM-SHA-256 (depends on MongoDB version)</p> <p>Limited Authorization: - Basic role-based access control (RBAC) - No advanced security features like:   - Auditing   - Field-level security   - Encryption at rest (without additional tools)</p>"},{"location":"security-guide/#network-security","title":"Network Security","text":""},{"location":"security-guide/#trusted-network-requirement","title":"Trusted Network Requirement","text":"<p>Since SSL/TLS is not available, Morphium must be deployed in trusted network environments:</p> <pre><code>// Configure for trusted network deployment\nMorphiumConfig cfg = new MorphiumConfig();\n\n// Internal network hosts only\ncfg.clusterSettings().addHostToSeed(\"internal-mongo1.company.local\", 27017);\ncfg.clusterSettings().addHostToSeed(\"internal-mongo2.company.local\", 27017);\ncfg.clusterSettings().addHostToSeed(\"internal-mongo3.company.local\", 27017);\n\n// Use internal DNS names, not public IPs\n</code></pre>"},{"location":"security-guide/#network-security-best-practices","title":"Network Security Best Practices","text":"<p>1. Network Isolation: <pre><code># MongoDB should only be accessible from application networks\n# Use firewall rules to restrict access\n\n# Allow only application servers\niptables -A INPUT -p tcp --dport 27017 -s 10.0.1.0/24 -j ACCEPT\niptables -A INPUT -p tcp --dport 27017 -j DROP\n\n# Or use cloud security groups\n# AWS: Restrict to application security groups only  \n# Azure: Use NSG rules for internal access only\n# GCP: Configure VPC firewall rules\n</code></pre></p> <p>2. VPN/Private Networks: <pre><code># Deploy MongoDB and applications in:\n# - Private VPC/VNet subnets\n# - Corporate VPN networks  \n# - Dedicated private networks\n# - Container overlay networks (Docker, Kubernetes)\n</code></pre></p> <p>3. Network Monitoring: <pre><code>// Monitor for unusual connection attempts\n@Component\npublic class SecurityMonitor {\n\n    @EventListener\n    public void onConnectionError(ConnectionErrorEvent event) {\n        // Log failed connection attempts for security analysis\n        securityLogger.warn(\"Connection attempt failed from: {} to: {}\", \n                           event.getSourceIP(), event.getTargetHost());\n    }\n}\n</code></pre></p>"},{"location":"security-guide/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"security-guide/#basic-authentication-configuration","title":"Basic Authentication Configuration","text":"<p>Application Authentication: <pre><code>MorphiumConfig cfg = new MorphiumConfig();\n\n// Use environment variables for credentials\ncfg.authSettings().setMongoLogin(System.getenv(\"MONGO_USERNAME\"));\ncfg.authSettings().setMongoPassword(System.getenv(\"MONGO_PASSWORD\"));\n\n// For replica set operations (if needed)\ncfg.authSettings().setMongoAdminUser(System.getenv(\"MONGO_ADMIN_USER\"));\ncfg.authSettings().setMongoAdminPwd(System.getenv(\"MONGO_ADMIN_PWD\"));\n</code></pre></p> <p>Never hardcode credentials: <pre><code>// \u274c NEVER DO THIS\ncfg.authSettings().setMongoLogin(\"hardcoded_user\");\ncfg.authSettings().setMongoPassword(\"hardcoded_password\");\n\n// \u2705 USE ENVIRONMENT VARIABLES OR SECURE VAULTS\ncfg.authSettings().setMongoLogin(System.getenv(\"MONGO_USERNAME\"));\ncfg.authSettings().setMongoPassword(getFromSecureVault(\"mongo.password\"));\n</code></pre></p>"},{"location":"security-guide/#mongodb-user-management","title":"MongoDB User Management","text":"<p>Create Application-Specific Users: <pre><code>// In MongoDB shell - create dedicated application user\nuse myapp_prod\n\n// Application user with minimal required permissions\ndb.createUser({\n  user: \"myapp_user\",\n  pwd: \"secure_random_password\",\n  roles: [\n    { role: \"readWrite\", db: \"myapp_prod\" },\n    { role: \"read\", db: \"myapp_config\" }\n  ]\n})\n\n// Admin user for replica set operations (if needed)\nuse admin\ndb.createUser({\n  user: \"myapp_admin\",\n  pwd: \"admin_secure_password\", \n  roles: [\n    { role: \"read\", db: \"local\" },\n    { role: \"clusterMonitor\", db: \"admin\" }\n  ]\n})\n</code></pre></p> <p>Role-Based Access Control: <pre><code>// Custom role for specific application needs\nuse admin\ndb.createRole({\n  role: \"myAppRole\",\n  privileges: [\n    {\n      resource: { db: \"myapp_prod\", collection: \"\" },\n      actions: [\"find\", \"insert\", \"update\", \"remove\"]\n    },\n    {\n      resource: { db: \"myapp_prod\", collection: \"sensitive_collection\" },\n      actions: [\"find\"] // Read-only for sensitive data\n    }\n  ],\n  roles: []\n})\n\n// Assign custom role to user\nuse myapp_prod\ndb.grantRolesToUser(\"myapp_user\", [\"myAppRole\"])\n</code></pre></p>"},{"location":"security-guide/#data-protection","title":"Data Protection","text":""},{"location":"security-guide/#application-level-encryption","title":"Application-Level Encryption","text":"<p>Since MongoDB Community Edition lacks encryption at rest, implement application-level encryption:</p> <pre><code>// Field-level encryption using Morphium's encryption support\n@Entity\npublic class SensitiveData {\n    @Id\n    private MorphiumId id;\n\n    @Encrypted // Encrypted before storing to MongoDB\n    private String socialSecurityNumber;\n\n    @Encrypted\n    private String creditCardNumber;\n\n    private String publicData; // Not encrypted\n}\n\n// Configure encryption provider\ncfg.encryptionSettings().setEncryptionKeyProvider(new AESEncryptionProvider());\ncfg.encryptionSettings().setEncryptionKey(getEncryptionKey());\n</code></pre> <p>Custom Encryption Implementation: <pre><code>@Component\npublic class DataEncryption {\n\n    private final AESUtil aes;\n\n    public String encryptSensitiveField(String plainText) {\n        if (plainText == null) return null;\n        return aes.encrypt(plainText, getFieldEncryptionKey());\n    }\n\n    public String decryptSensitiveField(String encryptedText) {\n        if (encryptedText == null) return null;\n        return aes.decrypt(encryptedText, getFieldEncryptionKey());\n    }\n\n    private String getFieldEncryptionKey() {\n        // Get from secure key management system\n        return keyManager.getKey(\"field_encryption_key\");\n    }\n}\n</code></pre></p>"},{"location":"security-guide/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>PII Data Protection: <pre><code>@Entity\npublic class UserProfile {\n    @Id\n    private MorphiumId id;\n\n    @Encrypted\n    private String email;\n\n    @Encrypted  \n    private String phoneNumber;\n\n    // Hash instead of storing directly\n    private String passwordHash;\n\n    // Tokenize sensitive IDs\n    private String userToken; // Use instead of actual user ID externally\n}\n\n// Implement data masking for logs\n@Override\npublic String toString() {\n    return \"UserProfile{\" +\n           \"id=\" + id +\n           \", email='\" + maskEmail(email) + '\\'' +\n           \", phoneNumber='\" + maskPhone(phoneNumber) + '\\'' +\n           '}';\n}\n</code></pre></p>"},{"location":"security-guide/#secure-configuration-management","title":"Secure Configuration Management","text":""},{"location":"security-guide/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Development Environment: <pre><code>// development.properties\ndatabase=myapp_dev\nhosts=localhost:27017\nmongo_login=dev_user\nmongo_password=dev_password\nlog_level=5\n</code></pre></p> <p>Production Environment: <pre><code>// production.properties - minimal logging\ndatabase=myapp_prod\nhosts=prod-mongo1:27017,prod-mongo2:27017,prod-mongo3:27017\nmongo_login=${MONGO_USERNAME}\nmongo_password=${MONGO_PASSWORD}\nlog_level=3\n</code></pre></p> <p>Container Security: <pre><code># Use non-root user\nRUN adduser --disabled-password --gecos '' appuser\nUSER appuser\n\n# Use secrets for sensitive data\n# Pass via environment variables from orchestrator\nENV MONGO_USERNAME=\"\"\nENV MONGO_PASSWORD=\"\"\n\n# Don't include credentials in image\nCOPY --chown=appuser:appuser app.jar /app/app.jar\n</code></pre></p> <p>Kubernetes Secrets: <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: mongo-credentials\ntype: Opaque\ndata:\n  username: bXlhcHBfdXNlcg== # base64 encoded\n  password: c2VjdXJlX3Bhc3N3b3Jk # base64 encoded\n\n---\napiVersion: apps/v1\nkind: Deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: myapp\n        env:\n        - name: MONGO_USERNAME\n          valueFrom:\n            secretKeyRef:\n              name: mongo-credentials\n              key: username\n        - name: MONGO_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mongo-credentials\n              key: password\n</code></pre></p>"},{"location":"security-guide/#audit-and-monitoring","title":"Audit and Monitoring","text":""},{"location":"security-guide/#security-event-logging","title":"Security Event Logging","text":"<p>Implement comprehensive security logging: <pre><code>@Component\npublic class SecurityAuditLogger {\n\n    private final Logger securityLog = LoggerFactory.getLogger(\"SECURITY\");\n\n    public void logAuthenticationAttempt(String username, boolean success, String sourceIP) {\n        securityLog.info(\"AUTH_ATTEMPT user={} success={} source={}\", \n                        username, success, sourceIP);\n    }\n\n    public void logDataAccess(String username, String collection, String operation) {\n        securityLog.info(\"DATA_ACCESS user={} collection={} operation={}\", \n                        username, collection, operation);\n    }\n\n    public void logSecurityViolation(String violation, String details) {\n        securityLog.warn(\"SECURITY_VIOLATION type={} details={}\", violation, details);\n    }\n}\n</code></pre></p> <p>Structured Security Logging: <pre><code>// Use structured logging for security events\n@Component  \npublic class StructuredSecurityLogger {\n\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public void logSecurityEvent(SecurityEvent event) {\n        try {\n            String jsonEvent = objectMapper.writeValueAsString(event);\n            securityLogger.info(\"SECURITY_EVENT: {}\", jsonEvent);\n        } catch (Exception e) {\n            securityLogger.error(\"Failed to log security event\", e);\n        }\n    }\n}\n\npublic class SecurityEvent {\n    private String eventType;\n    private String username;  \n    private String sourceIP;\n    private String resource;\n    private String operation;\n    private boolean success;\n    private LocalDateTime timestamp;\n    // ... getters/setters\n}\n</code></pre></p>"},{"location":"security-guide/#monitoring-security-metrics","title":"Monitoring Security Metrics","text":"<p>Track security-related metrics: <pre><code>@Component\npublic class SecurityMetrics {\n\n    private final MeterRegistry meterRegistry;\n\n    // Count authentication failures\n    private final Counter authFailures = Counter.builder(\"morphium.auth.failures\")\n                                                .register(meterRegistry);\n\n    // Count data access by type\n    private final Counter dataAccess = Counter.builder(\"morphium.data.access\")\n                                              .tag(\"operation\", \"read\")\n                                              .register(meterRegistry);\n\n    public void recordAuthFailure(String reason) {\n        authFailures.increment(Tags.of(\"reason\", reason));\n    }\n\n    public void recordDataAccess(String operation, String collection) {\n        dataAccess.increment(Tags.of(\"operation\", operation, \"collection\", collection));\n    }\n}\n</code></pre></p>"},{"location":"security-guide/#input-validation-and-injection-prevention","title":"Input Validation and Injection Prevention","text":""},{"location":"security-guide/#query-injection-prevention","title":"Query Injection Prevention","text":"<p>Use Morphium's type-safe query API: <pre><code>// \u2705 SAFE - Uses parameterized queries\nQuery&lt;User&gt; safeQuery = morphium.createQueryFor(User.class)\n    .f(\"username\").eq(userInput)  // Automatically escaped/parameterized\n    .f(\"status\").eq(\"active\");\n\n// \u274c DANGEROUS - Raw query construction\nQuery&lt;User&gt; unsafeQuery = morphium.createQueryFor(User.class)\n    .complexQuery(Doc.of(\"username\", userInput)); // Could allow injection\n</code></pre></p> <p>Input validation: <pre><code>@Component\npublic class InputValidator {\n\n    public void validateUsername(String username) {\n        if (username == null || username.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Username cannot be empty\");\n        }\n\n        if (username.length() &gt; 50) {\n            throw new IllegalArgumentException(\"Username too long\");\n        }\n\n        if (!username.matches(\"^[a-zA-Z0-9_-]+$\")) {\n            throw new IllegalArgumentException(\"Username contains invalid characters\");\n        }\n    }\n\n    public void validateEmail(String email) {\n        if (email == null || !email.matches(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$\")) {\n            throw new IllegalArgumentException(\"Invalid email format\");\n        }\n    }\n}\n</code></pre></p>"},{"location":"security-guide/#secure-development-practices","title":"Secure Development Practices","text":""},{"location":"security-guide/#code-security-review-checklist","title":"Code Security Review Checklist","text":"<p>Configuration Security: - [ ] No hardcoded credentials in source code - [ ] Environment variables used for sensitive data - [ ] Minimal database permissions granted - [ ] Network access properly restricted</p> <p>Data Protection: - [ ] Sensitive fields encrypted at application level - [ ] PII data properly masked in logs - [ ] Input validation implemented - [ ] Output encoding applied where needed</p> <p>Authentication/Authorization: - [ ] Strong password policies enforced - [ ] User roles properly defined and assigned - [ ] Session management secure - [ ] Access controls verified</p> <p>Logging and Monitoring: - [ ] Security events properly logged - [ ] Sensitive data not logged - [ ] Log files properly secured - [ ] Monitoring alerts configured</p>"},{"location":"security-guide/#security-testing","title":"Security Testing","text":"<p>Automated Security Testing: <pre><code>@Test\npublic class SecurityTests {\n\n    @Test\n    public void testNoCredentialsInLogs() {\n        // Verify no passwords appear in log files\n        String logContent = readLogFile();\n        assertFalse(\"Password leaked in logs\", \n                   logContent.contains(\"password\"));\n    }\n\n    @Test \n    public void testInputValidation() {\n        // Test SQL injection attempts\n        assertThrows(IllegalArgumentException.class, () -&gt; {\n            userService.findUser(\"'; DROP TABLE users; --\");\n        });\n    }\n\n    @Test\n    public void testEncryption() {\n        // Verify sensitive data is encrypted\n        SensitiveData data = new SensitiveData();\n        data.setSocialSecurityNumber(\"123-45-6789\");\n\n        morphium.store(data);\n\n        // Verify stored data is encrypted (not plaintext)\n        Doc stored = morphium.getDatabase()\n                            .getCollection(\"sensitive_data\")\n                            .find(Doc.of(\"_id\", data.getId()))\n                            .first();\n\n        assertNotEquals(\"123-45-6789\", stored.getString(\"socialSecurityNumber\"));\n    }\n}\n</code></pre></p>"},{"location":"security-guide/#security-incident-response","title":"Security Incident Response","text":""},{"location":"security-guide/#incident-response-plan","title":"Incident Response Plan","text":"<p>1. Immediate Response: - Identify compromised accounts/systems - Revoke compromised credentials immediately - Block suspicious network traffic - Isolate affected systems</p> <p>2. Investigation: - Analyze security logs for attack patterns - Identify data that may have been accessed - Determine attack vector and timeline - Document all findings</p> <p>3. Recovery: - Patch security vulnerabilities - Update all credentials - Restore from clean backups if needed - Implement additional security measures</p> <p>4. Post-Incident: - Update security procedures - Enhance monitoring and alerting - Conduct security training - Review and test incident response plan</p> <p>This security guide provides comprehensive coverage of security considerations for Morphium applications in MongoDB Community Edition environments, focusing on network security, authentication, data protection, and secure development practices.</p>"},{"location":"troubleshooting-guide/","title":"Troubleshooting Guide","text":"<p>Common issues and their solutions when using Morphium.</p>"},{"location":"troubleshooting-guide/#connection-issues","title":"Connection Issues","text":""},{"location":"troubleshooting-guide/#cannot-connect-to-mongodb","title":"Cannot Connect to MongoDB","text":"<p>Symptoms: - <code>MorphiumDriverException: Could not get connection to [host] in time [timeout]ms</code> - Application startup fails with connection timeout</p> <p>Diagnosis: <pre><code>&lt;!-- Enable debug logging for driver in log4j2.xml --&gt;\n&lt;Logger name=\"de.caluga.morphium.driver.wire.PooledDriver\" level=\"DEBUG\" additivity=\"false\"&gt;\n    &lt;AppenderRef ref=\"Console\"/&gt;\n&lt;/Logger&gt;\n</code></pre></p> <p>Common Causes &amp; Solutions:</p> <ol> <li> <p>Incorrect host/port configuration <pre><code>// Check your host configuration\ncfg.clusterSettings().addHostToSeed(\"correct-hostname\", 27017);\n</code></pre></p> </li> <li> <p>Network connectivity issues</p> </li> <li>Verify MongoDB is running: <code>mongosh --host hostname:port</code></li> <li>Check firewall rules and network policies</li> <li> <p>Test connectivity: <code>telnet hostname 27017</code></p> </li> <li> <p>Authentication failures <pre><code>// Verify credentials\ncfg.authSettings().setMongoLogin(\"correct-username\");\ncfg.authSettings().setMongoPassword(\"correct-password\");\n</code></pre></p> </li> <li> <p>Connection pool exhaustion <pre><code>// Increase connection limits\ncfg.connectionSettings().setMaxConnectionsPerHost(200);\ncfg.connectionSettings().setMaxWaitTime(10000);\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#replica-set-connection-issues","title":"Replica Set Connection Issues","text":"<p>Symptoms: - <code>MorphiumDriverException: No primary node defined - not connected yet?</code> - Intermittent connection failures</p> <p>Solutions: 1. Verify replica set configuration <pre><code>// In MongoDB shell\nrs.status()\nrs.conf()\n</code></pre></p> <ol> <li> <p>Check replica set name <pre><code>cfg.clusterSettings().setReplicaSetName(\"correct-replica-set-name\");\n</code></pre></p> </li> <li> <p>Add all replica set members to seed list <pre><code>cfg.clusterSettings().addHostToSeed(\"mongo1\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo2\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo3\", 27017);\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting-guide/#slow-query-performance","title":"Slow Query Performance","text":"<p>Symptoms: - High response times - CPU usage spikes - Memory growth</p> <p>Diagnosis: <pre><code>&lt;!-- Enable query logging in log4j2.xml --&gt;\n&lt;Logger name=\"de.caluga.morphium\" level=\"DEBUG\" additivity=\"false\"&gt;\n    &lt;AppenderRef ref=\"Console\"/&gt;\n&lt;/Logger&gt;\n</code></pre></p> <pre><code>// Monitor driver statistics\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\nSystem.out.println(\"Connections in use: \" + stats.get(DriverStatsKey.CONNECTIONS_IN_USE));\nSystem.out.println(\"Connections in pool: \" + stats.get(DriverStatsKey.CONNECTIONS_IN_POOL));\n</code></pre> <p>Solutions:</p> <ol> <li> <p>Add missing indexes <pre><code>@Entity\n@Index({\"fieldName\", \"composite,field\"}) // Add compound indexes\npublic class MyEntity {\n    @Index\n    private String frequentlyQueriedField;\n}\n\n// Create indexes manually\nmorphium.ensureIndicesFor(MyEntity.class);\n</code></pre></p> </li> <li> <p>Optimize query patterns <pre><code>// Use projection to limit returned fields\nQuery&lt;MyEntity&gt; q = morphium.createQueryFor(MyEntity.class)\n    .f(\"status\").eq(\"active\")\n    .project(\"name\", \"email\"); // Only return specific fields\n\n// Use pagination for large result sets\nList&lt;MyEntity&gt; results = q.skip(offset).limit(pageSize).asList();\n</code></pre></p> </li> <li> <p>Review caching configuration <pre><code>@Entity\n@Cache(timeout = 60000, maxEntries = 10000) // Adjust cache settings\npublic class MyEntity { /* ... */ }\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#memory-issues","title":"Memory Issues","text":"<p>Symptoms: - <code>OutOfMemoryError</code> - Gradual memory increase - Long GC pauses</p> <p>Diagnosis: <pre><code>// Monitor connection pool stats\nMap&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\nDouble connectionsInUse = stats.get(DriverStatsKey.CONNECTIONS_IN_USE);\nDouble connectionsInPool = stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\n\nSystem.out.println(\"Memory usage - Connections: \" + connectionsInUse + \"/\" + connectionsInPool);\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Connection pool sizing <pre><code>// Adjust pool size based on actual usage\ncfg.connectionSettings().setMaxConnectionsPerHost(50); // Reduce if too high\ncfg.connectionSettings().setMaxConnectionIdleTime(60000); // Close idle connections sooner\ncfg.connectionSettings().setMaxConnectionLifetime(300000); // Shorter connection lifetime\n</code></pre></p> </li> <li> <p>Cache tuning <pre><code>@Entity\n@Cache(maxEntries = 1000, timeout = 30000, strategy = Cache.ClearStrategy.LRU)\npublic class MyEntity { /* ... */ }\n</code></pre></p> </li> <li> <p>Large result set handling <pre><code>// Use iterator for large datasets\nMorphiumIterator&lt;MyEntity&gt; iterator = query.asIterable(100); // Process in batches\nwhile (iterator.hasNext()) {\n    MyEntity entity = iterator.next();\n    // Process entity\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#messaging-issues","title":"Messaging Issues","text":""},{"location":"troubleshooting-guide/#messages-not-being-processed","title":"Messages Not Being Processed","text":"<p>Symptoms: - Messages accumulating in queue - Listeners not receiving messages - High message latency</p> <p>Diagnosis: <pre><code>// Check messaging statistics\nMessagingStatsKey stats = messaging.getStats();\nSystem.out.println(\"Messages processed: \" + stats.getMessagesProcessed());\nSystem.out.println(\"Messages failed: \" + stats.getMessagesFailed());\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check listener registration <pre><code>// Ensure listener is properly registered\nmessaging.addListenerForTopic(\"mytopic\", (morphiumMessaging, msg) -&gt; {\n    System.out.println(\"Processing: \" + msg.getMsg());\n    return null; // or return response message\n});\n\n// Verify messaging is started\nmessaging.start();\n</code></pre></p> </li> <li> <p>Increase processing capacity <pre><code>// Configure for higher throughput\ncfg.messagingSettings().setMessagingWindowSize(200);\ncfg.messagingSettings().setMessagingMultithreadded(true);\ncfg.messagingSettings().setPollPauseTime(100); // Reduce pause time\n</code></pre></p> </li> <li> <p>Check for exceptions in listeners <pre><code>messaging.addListenerForTopic(\"mytopic\", (morphiumMessaging, msg) -&gt; {\n    try {\n        // Your processing logic\n        return processMessage(msg);\n    } catch (Exception e) {\n        log.error(\"Message processing failed\", e);\n        // Decide whether to return error response or null\n        return null;\n    }\n});\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#message-ordering-issues","title":"Message Ordering Issues","text":"<p>Symptoms: - Messages processed out of order - Race conditions in message processing</p> <p>Solutions:</p> <ol> <li> <p>Use exclusive messaging for ordering <pre><code>Msg msg = new Msg(\"ordered-topic\", \"content\", \"value\");\nmsg.setExclusive(true); // Ensure only one listener processes at a time\nmessaging.sendMessage(msg);\n</code></pre></p> </li> <li> <p>Single-threaded processing for critical topics <pre><code>// Configure single-threaded processing for specific topics\ncfg.messagingSettings().setMessagingMultithreadded(false);\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting-guide/#logging-and-debugging","title":"Logging and Debugging","text":""},{"location":"troubleshooting-guide/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>&lt;!-- Configure logging in log4j2.xml --&gt;\n&lt;Configuration&gt;\n    &lt;Appenders&gt;\n        &lt;Console name=\"Console\"&gt;\n            &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt;\n        &lt;/Console&gt;\n        &lt;File name=\"MorphiumLog\" fileName=\"/var/log/morphium/app.log\"&gt;\n            &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt;\n        &lt;/File&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;!-- Global debug logging for all Morphium components --&gt;\n        &lt;Logger name=\"de.caluga.morphium\" level=\"DEBUG\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"Console\"/&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;!-- Class-specific logging --&gt;\n        &lt;Logger name=\"de.caluga.morphium.driver.wire.PooledDriver\" level=\"DEBUG\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n        &lt;Logger name=\"de.caluga.morphium.messaging.StdMessaging\" level=\"DEBUG\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n\n        &lt;!-- Package-level logging --&gt;\n        &lt;Logger name=\"de.caluga.morphium.driver\" level=\"DEBUG\" additivity=\"false\"&gt;\n            &lt;AppenderRef ref=\"MorphiumLog\"/&gt;\n        &lt;/Logger&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre>"},{"location":"troubleshooting-guide/#key-log-patterns-to-watch","title":"Key Log Patterns to Watch","text":"<p>Connection Issues: <pre><code>ERROR: Could not get connection to [host] in time [timeout]ms\nWARN: Connection timeout\nERROR: Could not create connection to host [host]\n</code></pre></p> <p>Performance Issues: <pre><code>WARN: Connection pool exhausted\nDEBUG: Query took [time]ms\nWARN: Cache hit ratio low: [ratio]\n</code></pre></p> <p>Messaging Issues: <pre><code>ERROR: Message processing failed\nWARN: Message queue size growing: [size]\nDEBUG: Message processed in [time]ms\n</code></pre></p>"},{"location":"troubleshooting-guide/#monitoring-key-metrics","title":"Monitoring Key Metrics","text":""},{"location":"troubleshooting-guide/#connection-pool-metrics","title":"Connection Pool Metrics","text":"<pre><code>Map&lt;DriverStatsKey, Double&gt; stats = morphium.getDriver().getDriverStats();\n\n// Monitor these key metrics:\nDouble connectionsInUse = stats.get(DriverStatsKey.CONNECTIONS_IN_USE);\nDouble connectionsInPool = stats.get(DriverStatsKey.CONNECTIONS_IN_POOL);\nDouble connectionsOpened = stats.get(DriverStatsKey.CONNECTIONS_OPENED);\nDouble connectionsClosed = stats.get(DriverStatsKey.CONNECTIONS_CLOSED);\nDouble errors = stats.get(DriverStatsKey.ERRORS);\nDouble threadsWaiting = stats.get(DriverStatsKey.THREADS_WAITING_FOR_CONNECTION);\n</code></pre>"},{"location":"troubleshooting-guide/#performance-alerts","title":"Performance Alerts","text":"<p>Set up monitoring for these conditions:</p> <ol> <li>Connection pool exhaustion</li> <li> <p><code>connectionsInUse / maxConnectionsPerHost &gt; 0.8</code></p> </li> <li> <p>High error rate</p> </li> <li> <p><code>errors / (connectionsOpened + errors) &gt; 0.05</code></p> </li> <li> <p>Thread starvation</p> </li> <li> <p><code>threadsWaiting &gt; 0</code> for extended periods</p> </li> <li> <p>Connection churn</p> </li> <li>High <code>connectionsOpened</code> and <code>connectionsClosed</code> rates</li> </ol>"},{"location":"troubleshooting-guide/#common-configuration-mistakes","title":"Common Configuration Mistakes","text":""},{"location":"troubleshooting-guide/#1-undersized-connection-pool","title":"1. Undersized Connection Pool","text":"<pre><code>// Problem: Too few connections for load\ncfg.connectionSettings().setMaxConnectionsPerHost(5); // Too small\n\n// Solution: Size based on concurrent operations\ncfg.connectionSettings().setMaxConnectionsPerHost(50);\n</code></pre>"},{"location":"troubleshooting-guide/#2-excessive-connection-timeout","title":"2. Excessive Connection Timeout","text":"<pre><code>// Problem: Long timeouts hide connection issues\ncfg.connectionSettings().setMaxWaitTime(60000); // Too long\n\n// Solution: Fail fast to detect issues\ncfg.connectionSettings().setMaxWaitTime(5000);\n</code></pre>"},{"location":"troubleshooting-guide/#3-missing-indexes","title":"3. Missing Indexes","text":"<pre><code>// Problem: No indexes on frequently queried fields\n@Entity\npublic class User {\n    private String email; // Frequently queried but not indexed\n}\n\n// Solution: Add appropriate indexes\n@Entity\n@Index({\"email\", \"status,email\"}) // Single and compound indexes\npublic class User {\n    @Index\n    private String email;\n    private String status;\n}\n</code></pre>"},{"location":"troubleshooting-guide/#4-inefficient-cache-configuration","title":"4. Inefficient Cache Configuration","text":"<pre><code>// Problem: Cache settings don't match usage patterns\n@Cache(timeout = 1000, maxEntries = 100) // Too short timeout, too small cache\n\n// Solution: Match cache to data access patterns\n@Cache(timeout = 300000, maxEntries = 10000, strategy = Cache.ClearStrategy.LRU)\n</code></pre>"},{"location":"troubleshooting-guide/#getting-help","title":"Getting Help","text":"<p>When reporting issues, include:</p> <ol> <li>Configuration details (sanitized)</li> <li>Error logs with timestamps</li> <li>Driver statistics output</li> <li>MongoDB version and topology</li> <li>Java version and JVM settings</li> <li>Morphium version</li> <li>Steps to reproduce the issue</li> </ol> <pre><code>// Collect diagnostic information\nSystem.out.println(\"Morphium version: \" + Morphium.getVersion());\nSystem.out.println(\"Java version: \" + System.getProperty(\"java.version\"));\nSystem.out.println(\"Driver stats: \" + morphium.getDriver().getDriverStats());\nSystem.out.println(\"Configuration: \" + morphium.getConfig().toString());\n</code></pre>"},{"location":"howtos/aggregation-examples/","title":"Aggregation Examples","text":"<p>These examples use <code>Aggregator&lt;T,R&gt;</code> and <code>Expr</code> to build pipelines fluently.</p> <p>Imports used <pre><code>import de.caluga.morphium.aggregation.Aggregator;\nimport de.caluga.morphium.aggregation.Expr;\n</code></pre></p> <p>Creating an Aggregator: input and output types</p> <ul> <li>Signature: <code>morphium.createAggregator(IncomingEntity.class, OutputType.class)</code></li> <li>Incoming entity (<code>T</code>): determines the MongoDB collection and the available fields. This type must be a Morphium <code>@Entity</code>; Morphium uses its mapping to resolve the backing collection and validate field references.</li> <li>Output type (<code>R</code>): the class instantiated for each aggregation result. Use a POJO with matching fields/getters or <code>Map</code> for ad\u2011hoc shapes.</li> </ul> <p>Fail\u2011fast field validation</p> <ul> <li>Morphium is designed to help you \u201cfail fast\u201d. When you reference a field that does not exist on the entity, Morphium throws an exception instead of silently ignoring it.</li> <li>Prefer using enums or the lambda\u2011based field extractor to avoid typos when building queries and matches inside aggregations. See Field Names Without String Literals.</li> </ul> <p>1) Grouping with sums and averages <pre><code>Aggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.match(morphium.createQueryFor(Order.class).f(\"status\").eq(\"OPEN\"));\nagg.group(\"$customerId\").sum(\"total\", \"$amount\").avg(\"avgAmount\", \"$amount\").count(\"count\").end();\nagg.sort(\"-total\");\nList&lt;Map&gt; perCustomer = agg.aggregate();\n</code></pre></p> <p>2) Project computed fields and unwind arrays <pre><code>Aggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.unwind(\"$items\");\nagg.project(Expr.fields(\n  Expr.include(\"_id\", 0),\n  Expr.field(\"sku\", Expr.field(\"items.sku\")),\n  Expr.field(\"revenue\", Expr.multiply(Expr.field(\"items.price\"), Expr.field(\"items.qty\")))\n));\nagg.group(\"$sku\").sum(\"total\", \"$revenue\").count(\"sold\", 1).end();\nList&lt;Map&gt; perSku = agg.aggregate();\n</code></pre></p> <p>3) Lookup (join) with another collection <pre><code>Aggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.lookup(\"customers\", \"customerId\", \"_id\", \"customer\", null, null); // simple local/foreign join\nagg.unwind(\"$customer\");\nagg.project(\"_id\", \"amount\", \"customer.name\");\nList&lt;Map&gt; ordersWithCustomer = agg.aggregate();\n</code></pre></p> <p>4) Bucketing numeric values <pre><code>var boundaries = List.of(Expr.intExpr(0), Expr.intExpr(50), Expr.intExpr(100), Expr.intExpr(200));\nAggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.bucket(Expr.field(\"amount\"), boundaries, null, Map.of(\n  \"count\", Expr.sum(1),\n  \"sum\", Expr.sum(Expr.field(\"amount\"))\n));\nList&lt;Map&gt; byAmountBucket = agg.aggregate();\n</code></pre></p> <p>5) Automatic bucketing <pre><code>Aggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.bucketAuto(Expr.field(\"amount\"), 5, Map.of(\"sum\", Expr.sum(Expr.field(\"amount\"))), Aggregator.BucketGranularity.POWERSOF2);\nList&lt;Map&gt; buckets = agg.aggregate();\n</code></pre></p> <p>6) Sort by count and top\u2011N <pre><code>Aggregator&lt;Order, Map&gt; agg = morphium.createAggregator(Order.class, Map.class);\nagg.sortByCount(Expr.field(\"customerId\"));\nagg.limit(10);\nList&lt;Map&gt; topCustomers = agg.aggregate();\n</code></pre></p> <p>7) Graph lookup (hierarchical relations) <pre><code>Aggregator&lt;Employee, Map&gt; agg = morphium.createAggregator(Employee.class, Map.class);\nagg.graphLookup(\n  Employee.class,\n  Expr.field(\"$reportsTo\"), // start with\n  \"_id\",                   // connectFrom\n  \"reportsTo\",             // connectTo\n  \"hierarchy\",             // output array\n  5,                        // max depth\n  \"depth\",                 // depth field\n  null                      // optional match filter\n);\nList&lt;Map&gt; hierarchy = agg.aggregate();\n</code></pre></p> <p>8) Faceted search <pre><code>var base = morphium.createAggregator(Order.class, Map.class)\n  .match(morphium.createQueryFor(Order.class).f(\"status\").eq(\"OPEN\"));\n\nvar byCustomer = morphium.createAggregator(Order.class, Map.class)\n  .group(\"$customerId\").sum(\"total\", \"$amount\").end();\n\nvar byDay = morphium.createAggregator(Order.class, Map.class)\n  .project(Expr.fields(\n    Expr.field(\"day\", Expr.dateToString(\"%Y-%m-%d\", Expr.field(\"created\"))),\n    Expr.include(\"amount\")\n  ))\n  .group(\"$day\").sum(\"total\", \"$amount\").end();\n\nbase.facet(Map.of(\"byCustomer\", byCustomer, \"byDay\", byDay));\nList&lt;Map&gt; facets = base.aggregate();\n</code></pre></p> <p>9) Typed result projection <pre><code>public class SalesSummary {\n  private String customerId;\n  private BigDecimal total;\n  private long count;\n  // getters/setters\n}\n\nAggregator&lt;Order, SalesSummary&gt; agg = morphium.createAggregator(Order.class, SalesSummary.class);\nagg.group(\"$customerId\").sum(\"total\", \"$amount\").count(\"count\").end();\nList&lt;SalesSummary&gt; result = agg.aggregate();\n</code></pre></p> <p>Tips - Use <code>Expr</code> helpers to build expressions (e.g., <code>Expr.field</code>, <code>Expr.sum</code>, <code>Expr.divide</code>, <code>Expr.multiply</code>) - Use <code>project</code> to rename or compute fields and limit document size - Use <code>limit</code> early in the pipeline where appropriate See also: Developer Guide</p>"},{"location":"howtos/basic-setup/","title":"Basic Setup","text":"<p>Connect to a local MongoDB and configure Morphium.</p> <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"myapp\");\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\n\nMorphium morphium = new Morphium(cfg);\n</code></pre> <p>Replica set example <pre><code>cfg.clusterSettings().addHostToSeed(\"mongo1\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo2\", 27017);\ncfg.clusterSettings().addHostToSeed(\"mongo3\", 27017);\n</code></pre></p> <p>Authentication <pre><code>cfg.authSettings().setMongoLogin(\"user\");\ncfg.authSettings().setMongoPassword(\"secret\");\n</code></pre></p> <p>Driver selection (optional) <pre><code>cfg.driverSettings().setDriverName(\"PooledDriver\"); // default\n</code></pre></p>"},{"location":"howtos/cache-patterns/","title":"Cache Patterns","text":"<p>This page outlines common caching patterns with Morphium and when to use them.</p> <p>1) Read\u2011through entity cache (default) - Use <code>@Cache</code> on entities to enable read cache for queries and ID cache - Choose a clear strategy that matches your write rate and consistency needs <pre><code>@Cache(timeout = 30_000, clearOnWrite = true, strategy = Cache.ClearStrategy.LRU, syncCache = Cache.SyncCacheStrategy.CLEAR_TYPE_CACHE)\npublic class Product { ... }\n</code></pre> When to use - Most read\u2011heavy entities, where occasional stale reads for up to the TTL are acceptable</p> <p>2) Precise invalidation per entity (remove or update) - Reduce blast radius on writes by removing/updating only affected IDs instead of clearing the whole type cache <pre><code>@Cache(timeout = 60_000, clearOnWrite = true, syncCache = Cache.SyncCacheStrategy.REMOVE_ENTRY_FROM_TYPE_CACHE)\npublic class User { ... }\n</code></pre> or <pre><code>@Cache(timeout = 60_000, clearOnWrite = true, syncCache = Cache.SyncCacheStrategy.UPDATE_ENTRY)\npublic class User { ... }\n</code></pre> Notes - With <code>UPDATE_ENTRY</code>, other nodes re\u2011read the updated document (slightly higher cost, but fewer cache misses)</p> <p>3) Cluster\u2011wide synchronization via messaging - Ensure every node runs messaging and attach a <code>MessagingCacheSynchronizer</code> <pre><code>MorphiumMessaging messaging = morphium.createMessaging();\nmessaging.start();\nnew MessagingCacheSynchronizer(messaging, morphium);\n</code></pre> When to use - Multi\u2011node deployments that need consistent caches after writes</p> <p>4) TTL tuning and hot\u2011set sizing - Keep <code>@Cache.timeout</code> small enough to minimize staleness, large enough to reduce DB load - Use <code>maxEntries</code> and <code>strategy</code> to control memory use and eviction behavior <pre><code>@Cache(timeout = 15_000, maxEntries = 50_000, strategy = Cache.ClearStrategy.LRU)\npublic class Article { ... }\n</code></pre></p> <p>5) JCache integration and layering - Use <code>MorphiumCacheJCacheImpl</code> to adopt javax.cache - Optionally back it with an external provider for cross\u2011JVM cache layers <pre><code>MorphiumCacheJCacheImpl jcache = new MorphiumCacheJCacheImpl();\ncfg.cacheSettings().setCache(jcache);\n</code></pre></p> <p>6) Avoiding cache stampede - For heavy queries, consider:   - Pre\u2011warming popular keys at startup   - Adding small jitter to TTL at application level if you implement explicit invalidation   - Using <code>UPDATE_ENTRY</code> to keep hot IDs fresh without clearing type cache</p> <p>7) Eventual vs strong consistency - Read\u2011through caching is eventually consistent between nodes - To minimize staleness:   - Use smaller TTLs   - Prefer <code>REMOVE_ENTRY_FROM_TYPE_CACHE</code> or <code>UPDATE_ENTRY</code>   - Ensure messaging is available and responsive (replica set + change streams is preferred)</p> <p>8) Batching and write buffering - Global write buffering and async writes reduce DB pressure under load <pre><code>cfg.cacheSettings().setAsyncWritesEnabled(true);\ncfg.cacheSettings().setBufferedWritesEnabled(true);\n</code></pre> Trade\u2011off - Buffering can delay writes; choose TTLs and cache sync strategies accordingly</p> <p>9) Manual controls for maintenance <pre><code>// Clear one type\nmorphium.clearCachefor(Product.class);\n// Clear all types on all nodes\nnew MessagingCacheSynchronizer(messaging, morphium).sendClearAllMessage(\"maintenance\");\n</code></pre></p> <p>10) Query\u2011result cache keys - Morphium computes a deterministic key for queries (criteria + sort + projection + paging) - Prefer projections to keep cached result documents small</p> <p>See also - Caching Examples - Developer Guide</p>"},{"location":"howtos/caching-examples/","title":"Caching Examples","text":"<p>Morphium provides entity\u2011level caching via <code>@Cache</code> and supports cluster synchronization and JCache.</p> <p>1) Basic entity caching <pre><code>import de.caluga.morphium.annotations.caching.Cache;\n\n@Entity\n@Cache(\n  timeout = 30_000,              // 30s TTL\n  clearOnWrite = true,           // clear type cache on writes\n  strategy = Cache.ClearStrategy.LRU,\n  readCache = true,\n  syncCache = Cache.SyncCacheStrategy.CLEAR_TYPE_CACHE\n)\npublic class Product { ... }\n</code></pre></p> <p>2) Per\u2011type TTL override <pre><code>// Set a longer TTL for Product results at runtime\nmorphium.getCache().setValidCacheTime(Product.class, 120_000);\n</code></pre></p> <p>3) Cross\u2011node cache synchronization <pre><code>// Initialize messaging via factory and start it\nMorphiumMessaging messaging = morphium.createMessaging();\nmessaging.start();\n\n// Attach synchronizer: clears caches on other nodes when writes occur\nMessagingCacheSynchronizer sync = new MessagingCacheSynchronizer(messaging, morphium);\n\n// Optional: send a manual clear\u2011all\nsync.sendClearAllMessage(\"maintenance\");\n</code></pre></p> <p>4) Switch to JCache implementation <pre><code>// Use javax.cache\u2011based cache impl\nMorphiumCacheJCacheImpl jcache = new MorphiumCacheJCacheImpl();\ncfg.cacheSettings().setCache(jcache);\n\n// Optional: plug in a custom CacheManager\n// jcache.setCacheManager(myCacheManager);\n</code></pre></p> <p>5) Manual cache operations <pre><code>// Clear one type\nmorphium.clearCachefor(Product.class);\n\n// Reset all caches\nmorphium.getCache().resetCache();\n\n// Inspect an object by ID from cache (if present)\nProduct p = morphium.getCache().getFromIDCache(Product.class, productId);\n</code></pre></p> <p>6) Cache listeners (observe additions/removals) <pre><code>morphium.getCache().addCacheListener(new CacheListener() {\n  @Override public CacheEntry wouldAddToCache(String key, CacheEntry ce, boolean update) { return ce; }\n  @Override public boolean wouldClearCache(Class&lt;?&gt; type) { return true; }\n  @Override public boolean wouldRemoveEntryFromCache(String key, CacheEntry ce, boolean expired) { return true; }\n});\n</code></pre></p> <p>Notes - <code>@Cache.syncCache</code> controls how remote nodes update their caches:   - <code>CLEAR_TYPE_CACHE</code>: clear entire type cache on write   - <code>REMOVE_ENTRY_FROM_TYPE_CACHE</code>: remove single entry by ID   - <code>UPDATE_ENTRY</code>: re\u2011read updated entries - Ensure messaging is running on all nodes if you want cluster cache synchronization. See also: Cache Patterns, Developer Guide</p>"},{"location":"howtos/field-names/","title":"Field Names Without String Literals","text":"<p>Avoid hard\u2011coded string field names in queries to prevent typos and ease refactors/migrations.</p> <p>Option 1: Enums (recommended for teams) <pre><code>@Entity\npublic class User {\n  @Id private MorphiumId id;\n  private String userName;\n  public enum Fields { id, userName }\n}\n\nvar q = morphium.createQueryFor(User.class)\n  .f(User.Fields.userName).eq(\"alice\");\n</code></pre></p> <p>Option 2: Lambda property extractor (no codegen)</p> <ul> <li>Use a method reference to a getter; Morphium will receive the Java field name</li> <li>A small helper is included: <code>de.caluga.morphium.query.FieldNames</code> and <code>Property</code> <pre><code>import static de.caluga.morphium.query.FieldNames.of;\n\nvar q = morphium.createQueryFor(User.class)\n  .f(of(User::getUserName)).eq(\"alice\");\n</code></pre></li> </ul> <p>Notes</p> <ul> <li>Works with <code>@Entity(translateCamelCase = true)</code>\u2014use Java field names in queries, Morphium maps to stored names.</li> <li>Requires normal JavaBean getter names (<code>getXxx</code> or <code>isXxx</code>).</li> </ul> <p>Option 3: Code generation at build time (annotation processor)</p> <ul> <li>Create a simple JSR\u2011269 annotation processor that scans <code>@Entity</code> classes and generates <code>Fields</code> enums or <code>User_</code> constants classes using JavaPoet.</li> <li>Wire it via Maven\u2019s <code>maven-compiler-plugin</code> <code>annotationProcessorPaths</code> or run a generator via <code>exec-maven-plugin</code> in the <code>generate-sources</code> phase to write sources into <code>target/generated-sources</code>.</li> <li>Pros: strongly typed enums/constants; Cons: extra module/maintenance.</li> </ul> <p>Recommendation</p> <ul> <li>Start with Enums or the Lambda extractor. If your model is large or changes often, consider adding a lightweight codegen step later.</li> </ul>"},{"location":"howtos/inmemory-driver/","title":"InMemory Driver &amp; MorphiumServer","text":"<p>This page has been split into two focused documents: - InMemory Driver - For embedded in-memory driver usage (unit tests, embedded applications) - MorphiumServer - For standalone MongoDB-compatible server (CI/CD, microservices, integration testing)</p>"},{"location":"howtos/inmemory-driver/#quick-links","title":"Quick Links","text":""},{"location":"howtos/inmemory-driver/#for-testing-and-development","title":"For Testing and Development","text":"<p>If you want to run Morphium without MongoDB for unit tests or embedded applications: - \ud83d\udc49 InMemory Driver Documentation</p>"},{"location":"howtos/inmemory-driver/#for-standalone-server","title":"For Standalone Server","text":"<p>If you want to run a MongoDB-compatible server that other applications can connect to: - \ud83d\udc49 MorphiumServer Documentation</p>"},{"location":"howtos/inmemory-driver/#at-a-glance","title":"At a Glance","text":"<p>InMemory Driver: - Embedded in-process driver - No network overhead - Perfect for unit tests - Use with: <code>cfg.driverSettings().setDriverName(\"InMemDriver\")</code></p> <p>MorphiumServer: - Standalone network server - MongoDB wire protocol compatible - Any MongoDB client can connect - Run with: <code>java -cp morphium.jar de.caluga.morphium.server.MorphiumServer --port 27017</code></p>"},{"location":"howtos/inmemory-driver/#core-operations","title":"Core Operations","text":"<ul> <li>\u2705 CRUD Operations: insert, find, update, delete, upsert</li> <li>\u2705 Queries: $eq, $ne, $gt, $gte, $lt, $lte, $in, $nin, $exists, $regex</li> <li>\u2705 Logical Operators: $and, $or, $not, $nor</li> <li>\u2705 Array Operators: $elemMatch, $all, $size</li> <li>\u2705 Projections: Field inclusion/exclusion, nested fields</li> <li>\u2705 Sorting &amp; Pagination: sort(), skip(), limit()</li> </ul>"},{"location":"howtos/inmemory-driver/#aggregation-pipeline","title":"Aggregation Pipeline","text":"<ul> <li>\u2705 Basic Stages: $match, $group, $sort, $limit, $skip, $project</li> <li>\u2705 Group Operators: $sum, $avg, $min, $max, $first, $last, $push, $addToSet</li> <li>\u2705 MapReduce: Full JavaScript-based MapReduce with GraalJS engine</li> <li>\u26a0\ufe0f Advanced Stages: $lookup, $unwind, $facet (limited support)</li> </ul>"},{"location":"howtos/inmemory-driver/#change-streams-v60","title":"Change Streams (v6.0)","text":"<ul> <li>\u2705 Event Types: insert, update, delete, drop operations</li> <li>\u2705 Document Snapshots: Immutable snapshots prevent dirty reads</li> <li>\u2705 Pipeline Filtering: Filter events with aggregation pipelines</li> <li>\u2705 Full Document Support: Access complete document in change events</li> <li>\u2705 Database-scoped Sharing: Multiple Morphium instances share driver per database</li> </ul>"},{"location":"howtos/inmemory-driver/#messaging-system-v60","title":"Messaging System (v6.0)","text":"<ul> <li>\u2705 StandardMessaging: Single-collection messaging with change streams</li> <li>\u2705 MultiCollectionMessaging: Multi-collection messaging</li> <li>\u2705 Exclusive Messages: Single-consumer message processing</li> <li>\u2705 Broadcast Messages: Multi-consumer message distribution</li> <li>\u2705 Message Locking: Proper lock collection support</li> </ul>"},{"location":"howtos/inmemory-driver/#indexes","title":"Indexes","text":"<ul> <li>\u2705 Single Field Indexes: Basic indexing support</li> <li>\u26a0\ufe0f Compound Indexes: Limited support</li> <li>\u274c Text Indexes: Not fully implemented</li> <li>\u274c Geospatial Indexes: Limited geospatial support</li> </ul>"},{"location":"howtos/inmemory-driver/#transactions","title":"Transactions","text":"<ul> <li>\u2705 Basic Transactions: start, commit, abort (single-instance)</li> <li>\u274c Multi-document ACID: Limited to single instance</li> <li>\u274c Distributed Transactions: No replica set support</li> </ul>"},{"location":"howtos/inmemory-driver/#v60-improvements","title":"V6.0 Improvements","text":""},{"location":"howtos/inmemory-driver/#change-stream-enhancements","title":"Change Stream Enhancements","text":"<p>The v6.0 release significantly improved change stream reliability:</p> <p>Deep Copy Snapshots <pre><code>// Documents are deep-copied before change stream events are dispatched\n// This prevents dirty reads where documents are modified before callbacks execute\nmorphium.watch(UncachedObject.class, evt -&gt; {\n    // evt.getFullDocument() contains an immutable snapshot\n    // Safe to process without worrying about concurrent modifications\n});\n</code></pre></p> <p>Database-scoped Driver Sharing <pre><code>// Multiple Morphium instances sharing the same database will share the driver\nMorphiumConfig cfg1 = new MorphiumConfig();\ncfg1.connectionSettings().setDatabase(\"testdb\");\ncfg1.driverSettings().setDriverName(\"InMemDriver\");\nMorphium m1 = new Morphium(cfg1);\n\nMorphiumConfig cfg2 = new MorphiumConfig();\ncfg2.connectionSettings().setDatabase(\"testdb\");  // same database\ncfg2.driverSettings().setDriverName(\"InMemDriver\");\nMorphium m2 = new Morphium(cfg2);\n\n// m1 and m2 share the same InMemoryDriver instance\n// Change streams work correctly across both instances\n// Driver is only closed when the last Morphium instance closes\n</code></pre></p> <p>Reference Counting - Automatic reference counting prevents premature driver shutdown - Each Morphium instance increments the ref count on creation - Driver shuts down only when ref count reaches zero - Solves issues with tests that create multiple Morphium instances</p>"},{"location":"howtos/inmemory-driver/#messaging-improvements","title":"Messaging Improvements","text":"<p>No More Re-reads <pre><code>// v5: messaging layer re-read documents from change stream events\n// v6: uses evt.getFullDocument() directly - more efficient, no dirty reads\nMorphiumMessaging msg = morphium.createMessaging();\nmsg.addListenerForTopic(\"events\", (m, message) -&gt; {\n    // message is from the immutable snapshot, not a re-read\n    return null;\n});\n</code></pre></p> <p>Better Multi-Instance Support <pre><code>// Tests with multiple messaging instances now work correctly\nMorphium m1 = new Morphium(cfg);\nMorphium m2 = new Morphium(cfg);  // same database\n\nMorphiumMessaging msg1 = m1.createMessaging();\nMorphiumMessaging msg2 = m2.createMessaging();\n\n// Both receive change stream events correctly\n// Exclusive messages work as expected\n// Broadcast messages delivered to all listeners\n</code></pre></p>"},{"location":"howtos/inmemory-driver/#mapreduce-support","title":"MapReduce Support","text":"<p>The InMemory driver includes full MapReduce support using the GraalJS JavaScript engine.</p>"},{"location":"howtos/inmemory-driver/#basic-example","title":"Basic Example","text":"<pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.driverSettings().setDriverName(\"InMemDriver\");\ncfg.connectionSettings().setDatabase(\"testdb\");\n\ntry (Morphium morphium = new Morphium(cfg)) {\n    // Insert sample data\n    for (int i = 0; i &lt; 100; i++) {\n        MyEntity entity = new MyEntity();\n        entity.setCategory(i % 5);  // 5 categories\n        entity.setValue(i);\n        morphium.store(entity);\n    }\n\n    // Map function (JavaScript)\n    String mapFunction = \"\"\"\n        function() {\n            emit(this.category, this.value);\n        }\n        \"\"\";\n\n    // Reduce function (JavaScript)\n    String reduceFunction = \"\"\"\n        function(key, values) {\n            return values.reduce((sum, val) =&gt; sum + val, 0);\n        }\n        \"\"\";\n\n    // Execute MapReduce\n    List&lt;Map&lt;String, Object&gt;&gt; results = morphium.mapReduce(\n        MyEntity.class,\n        mapFunction,\n        reduceFunction\n    );\n\n    // Process results\n    results.forEach(r -&gt;\n        System.out.println(\"Category: \" + r.get(\"_id\") + \", Total: \" + r.get(\"value\"))\n    );\n}\n</code></pre>"},{"location":"howtos/inmemory-driver/#javascript-engine","title":"JavaScript Engine","text":"<ul> <li>Engine: GraalJS (modern ES6+ compatible)</li> <li>Available: <code>emit(key, value)</code> function and all standard JavaScript built-ins</li> <li>Performance: Fast in-memory execution, single-threaded</li> </ul> <p>For more MapReduce examples, see the InMemory Driver documentation.</p>"},{"location":"howtos/inmemory-driver/#limitations","title":"Limitations","text":""},{"location":"howtos/inmemory-driver/#not-supported","title":"Not Supported","text":"<ul> <li>\u274c Replica Sets: No replica set simulation</li> <li>\u274c Sharding: No shard key or distributed queries</li> <li>\u274c Full Text Search: Limited $text operator support</li> <li>\u274c Advanced Geospatial: Basic $near/$geoWithin only</li> <li>\u274c GridFS: No file storage support</li> <li>\u274c Time Series Collections: Not implemented</li> <li>\u274c Authentication: No user/role management</li> <li>\u274c $lookup Joins: Not yet implemented</li> </ul>"},{"location":"howtos/inmemory-driver/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory Usage: All data stored in memory</li> <li>No Persistence: Data lost when driver closes</li> <li>Concurrency: Uses ReadWriteLock for thread safety</li> <li>Index Performance: Limited compared to MongoDB's B-tree indexes</li> </ul>"},{"location":"howtos/inmemory-driver/#testing-strategies","title":"Testing Strategies","text":""},{"location":"howtos/inmemory-driver/#unit-tests","title":"Unit Tests","text":"<pre><code>@Test\npublic void testWithInMemory() {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.driverSettings().setDriverName(\"InMemDriver\");\n    cfg.connectionSettings().setDatabase(\"unittest\");\n\n    try (Morphium morphium = new Morphium(cfg)) {\n        // Test code here\n        // No MongoDB required!\n    }\n}\n</code></pre>"},{"location":"howtos/inmemory-driver/#shared-driver-tests","title":"Shared Driver Tests","text":"<pre><code>@Test\npublic void testMultipleInstances() {\n    String dbName = \"shareddb\";\n\n    MorphiumConfig cfg1 = new MorphiumConfig();\n    cfg1.driverSettings().setDriverName(\"InMemDriver\");\n    cfg1.connectionSettings().setDatabase(dbName);\n\n    MorphiumConfig cfg2 = new MorphiumConfig();\n    cfg2.driverSettings().setDriverName(\"InMemDriver\");\n    cfg2.connectionSettings().setDatabase(dbName);\n\n    try (Morphium m1 = new Morphium(cfg1);\n         Morphium m2 = new Morphium(cfg2)) {\n\n        // Both share the same driver\n        // Write with m1, read with m2\n        m1.store(new MyEntity(\"test\"));\n        MyEntity found = m2.findById(MyEntity.class, id);\n\n        // Works correctly!\n    }\n}\n</code></pre>"},{"location":"howtos/inmemory-driver/#messaging-tests","title":"Messaging Tests","text":"<pre><code>@Test\npublic void testMessaging() throws Exception {\n    MorphiumConfig cfg = new MorphiumConfig();\n    cfg.driverSettings().setDriverName(\"InMemDriver\");\n    cfg.connectionSettings().setDatabase(\"msgtest\");\n\n    try (Morphium morphium = new Morphium(cfg)) {\n        MorphiumMessaging sender = morphium.createMessaging();\n        MorphiumMessaging receiver = morphium.createMessaging();\n\n        AtomicInteger count = new AtomicInteger(0);\n\n        receiver.addListenerForTopic(\"test\", (m, msg) -&gt; {\n            count.incrementAndGet();\n            return null;\n        });\n\n        sender.start();\n        receiver.start();\n\n        sender.sendMessage(new Msg(\"test\", \"Hello\", \"World\", 30000));\n\n        Thread.sleep(500);\n        assertEquals(1, count.get());\n    }\n}\n</code></pre>"},{"location":"howtos/inmemory-driver/#monitoring","title":"Monitoring","text":"<p>Built-in Status Monitoring: When using messaging with InMemory driver, all instances automatically respond to <code>morphium_status</code> queries. This provides JVM, messaging, and driver metrics without any setup.</p> <pre><code>MorphiumMessaging sender = morphium.createMessaging();\nsender.start();\n\n// Query status from all instances\nList&lt;Msg&gt; responses = sender.sendAndAwaitAnswers(\n    new Msg(sender.getStatusInfoListenerName(), \"status\", \"ALL\"),\n    5, 2000\n);\n\n// Check metrics\nfor (Msg r : responses) {\n    Map&lt;String, Object&gt; stats = r.getMapValue();\n    System.out.println(\"Heap: \" + stats.get(\"jvm.heap.used\"));\n    System.out.println(\"Processing: \" + stats.get(\"messaging.processing\"));\n}\n</code></pre> <p>See Messaging - Built-in Status Monitoring for complete documentation.</p>"},{"location":"howtos/inmemory-driver/#best-practices","title":"Best Practices","text":"<ol> <li>Use for Unit Tests Only: Not intended for production</li> <li>Separate Database Names: Different test classes should use different database names to avoid interference</li> <li>Clean Up: Use try-with-resources to ensure proper cleanup</li> <li>Test Against Real MongoDB: Always verify behavior against actual MongoDB before production</li> <li>Watch Memory Usage: Large datasets can consume significant memory</li> </ol>"},{"location":"howtos/inmemory-driver/#troubleshooting","title":"Troubleshooting","text":""},{"location":"howtos/inmemory-driver/#issue-change-streams-not-working","title":"Issue: Change streams not working","text":"<p>Solution: Ensure you're using v6.0+ with the deep copy snapshot fix</p>"},{"location":"howtos/inmemory-driver/#issue-messages-not-received-by-all-listeners","title":"Issue: Messages not received by all listeners","text":"<p>Solution: Use database-scoped sharing by ensuring all Morphium instances use the same database name</p>"},{"location":"howtos/inmemory-driver/#issue-nullpointerexception-in-insert","title":"Issue: NullPointerException in insert()","text":"<p>Solution: Upgrade to v6.0+ which includes index data structure initialization fix</p>"},{"location":"howtos/inmemory-driver/#issue-driver-shutdown-too-early","title":"Issue: Driver shutdown too early","text":"<p>Solution: v6.0+ includes reference counting to prevent premature shutdown</p>"},{"location":"howtos/inmemory-driver/#see-also","title":"See Also","text":"<ul> <li><code>docs/howtos/messaging-implementations.md</code> - Messaging patterns</li> <li><code>docs/testing-guide.md</code> - Testing strategies</li> <li><code>docs/howtos/migration-v5-to-v6.md</code> - Migration guide</li> </ul> <p>See the dedicated documentation pages above for complete guides, examples, and API reference.</p>"},{"location":"howtos/messaging-implementations/","title":"Messaging Implementations","text":"<p>Morphium provides two messaging implementations that share the same API (<code>MorphiumMessaging</code>) but differ in storage layout and scalability characteristics.</p>"},{"location":"howtos/messaging-implementations/#summary","title":"Summary","text":"<ul> <li>Standard (<code>StdMessaging</code>, name: <code>StandardMessaging</code>)</li> <li>Single queue collection per queue name (e.g., <code>msg</code>).</li> <li>Direct messages (recipient\u2011targeted) are stored in the same collection.</li> <li>One lock collection per queue (e.g., <code>msg_lck</code>) for exclusive messages.</li> <li> <p>Simpler layout, good default for small to medium setups or few topics.</p> </li> <li> <p>Advanced (<code>AdvancedSplitCollectionMessaging</code>, name: <code>AdvMessaging</code>)</p> </li> <li>One collection per topic: <code>&lt;queue&gt;_&lt;topic&gt;</code> (spaces, dashes, slashes removed).</li> <li>Direct messages use a dedicated collection per recipient: <code>dm_&lt;senderIdCamelCase&gt;</code>.</li> <li>Lock collections per topic: <code>&lt;queue&gt;_lck_&lt;topic&gt;</code>.</li> <li>Optimized change stream efficiency and reduced contention on busy/many\u2011topic systems.</li> </ul> <p>Both support: - Change Streams vs polling (<code>useChangeStream</code>), window size, multithreading, answers, exclusive vs broadcast.</p>"},{"location":"howtos/messaging-implementations/#choosing-an-implementation","title":"Choosing an Implementation","text":"<ul> <li>Start with Standard. If you have many topics, high listener fan\u2011out, or change streams getting noisy, move to Advanced.</li> <li>Names used for selection:</li> <li><code>StandardMessaging</code> \u2192 <code>StdMessaging</code></li> <li><code>AdvMessaging</code> \u2192 <code>AdvancedSplitCollectionMessaging</code></li> </ul>"},{"location":"howtos/messaging-implementations/#configuration-and-usage","title":"Configuration and Usage","text":"<p>Always instantiate via <code>Morphium.createMessaging()</code> so configuration and implementation selection are handled correctly.</p> <pre><code>// Configure implementation by name\ncfg.messagingSettings().setMessagingImplementation(\"AdvMessaging\"); // or \"StandardMessaging\" (default)\n\nMorphium morphium = new Morphium(cfg);\nMorphiumMessaging messaging = morphium.createMessaging();\nmessaging.start();\n\nmessaging.addListenerForTopic(\"orders.created\", (mm, msg) -&gt; {\n  // ...\n  return null;\n});\n</code></pre> <p>Relevant settings are the same for both implementations (see the Messaging page): - <code>messageQueueName</code>, <code>messagingWindowSize</code>, <code>messagingMultithreadded</code>, <code>useChangeStream</code>, <code>messagingPollPause</code>.</p>"},{"location":"howtos/messaging-implementations/#storage-layout-details","title":"Storage Layout Details","text":"<ul> <li>Standard</li> <li>Queue: <code>&lt;queue&gt;</code> (default <code>msg</code>)</li> <li>Locks: <code>&lt;queue&gt;_lck</code></li> <li> <p>Direct messages: <code>&lt;queue&gt;</code></p> </li> <li> <p>Advanced</p> </li> <li>Topic queue: <code>&lt;queue&gt;_&lt;topic&gt;</code></li> <li>Locks: <code>&lt;queue&gt;_lck_&lt;topic&gt;</code></li> <li>Direct messages: <code>dm_&lt;recipientSenderIdCamelCase&gt;</code></li> </ul>"},{"location":"howtos/messaging-implementations/#migrating-standard-advanced","title":"Migrating Standard \u2192 Advanced","text":"<p>Because the storage layout changes, do not mix Standard and Advanced nodes for the same application at the same time.</p> <p>Recommended approaches - Big\u2011bang switch (simplest):   - Drain or pause message producers.   - Stop all consumers (nodes).   - Update config: <code>cfg.messagingSettings().setMessagingImplementation(\"AdvMessaging\")</code>.   - Start all nodes; verify listeners on expected topics; resume producers.</p> <ul> <li>Transitional bridge (optional):</li> <li>If you must avoid downtime, temporarily run a small bridge process that reads from Standard (<code>msg</code>) and republishes into Advanced per\u2011topic collections using the same <code>Msg</code> payloads. Switch all nodes to Advanced, then remove the bridge.</li> </ul> <p>Notes - Producers and consumers use the same <code>MorphiumMessaging</code> API. The change is purely implementation/configuration. - Topic names do not change. Advanced derives collection names from topics automatically. - Indexes are ensured automatically by both implementations on startup. - Clean\u2011up: once fully migrated, you may drop the old Standard queue collections (<code>&lt;queue&gt;</code>, <code>&lt;queue&gt;_lck</code>) after verifying they\u2019re unused.</p>"},{"location":"howtos/messaging-implementations/#cache-synchronization","title":"Cache Synchronization","text":"<p>Both implementations work with <code>MessagingCacheSynchronizer</code>. No code changes needed\u2014only the implementation selection via config.</p>"},{"location":"howtos/migration-v5-to-v6/","title":"Migration v5 \u2192 v6","text":""},{"location":"howtos/migration-v5-to-v6/#requirements","title":"Requirements","text":"<ul> <li>Java 21+ (mandatory)</li> <li>MongoDB 5.0+ for production deployments</li> <li>BSON library: Morphium 6 uses MongoDB's BSON library (version 4.7.1+)</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#breaking-changes","title":"Breaking Changes","text":""},{"location":"howtos/migration-v5-to-v6/#1-configuration-api-changes","title":"1. Configuration API Changes","text":"<p>Old (v5): <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.setDatabase(\"mydb\");\ncfg.setHosts(\"localhost:27017\");\ncfg.setDriverName(\"PooledDriver\");\n</code></pre></p> <p>New (v6): <pre><code>MorphiumConfig cfg = new MorphiumConfig();\ncfg.connectionSettings().setDatabase(\"mydb\");\ncfg.clusterSettings().addHostToSeed(\"localhost\", 27017);\ncfg.driverSettings().setDriverName(\"PooledDriver\");\n</code></pre></p> <p>Prefer the new nested settings objects: - <code>connectionSettings()</code> - database name, credentials, timeouts - <code>clusterSettings()</code> - hosts, replica set configuration - <code>driverSettings()</code> - driver selection and configuration - <code>messagingSettings()</code> - messaging implementation and settings - <code>cacheSettings()</code> - caching configuration - <code>encryptionSettings()</code> - encryption keys</p>"},{"location":"howtos/migration-v5-to-v6/#2-driver-selection","title":"2. Driver Selection","text":"<ul> <li>v5 and v6: select drivers by name via <code>MorphiumConfig.driverSettings().setDriverName(name)</code>.</li> <li>Built\u2011in driver names:</li> <li><code>PooledDriver</code> - Connection-pooled MongoDB driver (default for production)</li> <li><code>SingleMongoConnectDriver</code> - Single-connection driver</li> <li><code>InMemDriver</code> - In-memory driver for testing (no MongoDB required)</li> <li>Custom drivers must be annotated with <code>@de.caluga.morphium.annotations.Driver(name = \"YourName\")</code> to be discoverable.</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#3-messaging-api","title":"3. Messaging API","text":"<p>Old (v5): <pre><code>Messaging m = new Messaging(morphium, 100, true);\nm.setSenderId(\"myapp\");\n</code></pre></p> <p>New (v6): <pre><code>// Use factory method for correct configuration\nMorphiumMessaging m = morphium.createMessaging();\nm.setSenderId(\"myapp\");\nm.start();\nm.addListenerForTopic(\"topic\", (mm, msg) -&gt; {\n    // process message\n    return null;\n});\n</code></pre></p> <ul> <li>Always use <code>Morphium.createMessaging()</code> so configuration and implementation selection happen correctly</li> <li>The messaging implementation is chosen by name from <code>MorphiumConfig.messagingSettings().getMessagingImplementation()</code></li> <li>Built-in implementations:</li> <li><code>StandardMessaging</code> (default) - Single-collection messaging</li> <li><code>MultiCollectionMessaging</code> - Multi-collection messaging for high-volume scenarios</li> <li>Custom implementations must be annotated with <code>@de.caluga.morphium.annotations.Messaging(name = \"YourName\")</code></li> </ul>"},{"location":"howtos/migration-v5-to-v6/#message-name-field-renamed-to-topic","title":"Message \"name\" field renamed to \"topic\"","text":"<p>In v6, the <code>Msg</code> class field and methods have been renamed from \"name\" to \"topic\" to align with standard messaging terminology:</p> <p>Old (v5): <pre><code>Msg msg = new Msg(\"myMessageName\", \"command\", \"data\");\nString name = msg.getName();\nmsg.setName(\"newName\");\n</code></pre></p> <p>New (v6): <pre><code>Msg msg = new Msg(\"myTopic\", \"command\", \"data\");\nString topic = msg.getTopic();\nmsg.setTopic(\"newTopic\");\n</code></pre></p> <p>Backward compatibility: - The MongoDB field is backward compatible via <code>@Aliases({\"name\"})</code> annotation - V5 and V6 messaging instances can communicate if <code>SingleCollectionMessaging</code> (now called <code>StandardMessaging</code>) is used in V6 - Existing MongoDB documents with the \"name\" field will continue to work</p> <p>Removed deprecated methods: - <code>getName()</code> \u2192 use <code>getTopic()</code> - <code>setName(String)</code> \u2192 use <code>setTopic(String)</code> - <code>sendAnswer(Messaging, Msg)</code> \u2192 removed (use messaging instance methods instead)</p>"},{"location":"howtos/migration-v5-to-v6/#4-null-value-handling-changes","title":"4. Null Value Handling Changes","text":"<p>Morphium v6 changes how null values are handled during serialization and deserialization to be more consistent with MongoDB behavior and other ORMs.</p>"},{"location":"howtos/migration-v5-to-v6/#new-default-behavior-v6","title":"New Default Behavior (v6)","text":"<p>Field missing from MongoDB document: - Java field is NOT updated (preserves default values or existing values) - This is consistent behavior regardless of annotations</p> <p>Field present in MongoDB with explicit null value: - By default, Java field IS set to null (overwrites default values) - Use <code>@IgnoreNullFromDB</code> to protect specific fields from null contamination</p> <p>Old (v5): <pre><code>@Entity\npublic class MyEntity {\n    private Integer counter = 42;  // null from DB would be ignored (protected)\n\n    @UseIfnull\n    private String name;           // null from DB would be accepted\n}\n</code></pre></p> <p>New (v6): <pre><code>@Entity\npublic class MyEntity {\n    private Integer counter = 42;  // null from DB IS accepted (becomes null)\n\n    @IgnoreNullFromDB\n    private Integer protectedCounter = 99;  // null from DB is ignored (stays 99)\n}\n</code></pre></p>"},{"location":"howtos/migration-v5-to-v6/#migration-strategy","title":"Migration Strategy","text":"<p>The <code>@UseIfnull</code> annotation is now deprecated. The behavior has been inverted:</p> <p>Old behavior (v5): - Fields WITHOUT <code>@UseIfnull</code>: ignored nulls from DB (protected) - Fields WITH <code>@UseIfnull</code>: accepted nulls from DB</p> <p>New behavior (v6): - Fields WITHOUT <code>@IgnoreNullFromDB</code>: accept nulls from DB (standard behavior) - Fields WITH <code>@IgnoreNullFromDB</code>: ignore nulls from DB (protected)</p> <p>To migrate: 1. Remove <code>@UseIfnull</code> from fields that should accept nulls (this is now the default) 2. Add <code>@IgnoreNullFromDB</code> to fields that previously did NOT have <code>@UseIfnull</code> if you want to maintain the old protection behavior</p>"},{"location":"howtos/migration-v5-to-v6/#example-field-missing-vs-explicit-null","title":"Example: Field Missing vs. Explicit Null","text":"<pre><code>@Entity\npublic class Example {\n    private String regularField = \"default\";\n\n    @IgnoreNullFromDB\n    private String protectedField = \"default\";\n}\n</code></pre> <p>Scenario 1: MongoDB document is <code>{}</code> (field missing entirely) - <code>regularField</code> stays \"default\" - <code>protectedField</code> stays \"default\"</p> <p>Scenario 2: MongoDB document is <code>{ regularField: null, protectedField: null }</code> - <code>regularField</code> becomes null (default overwritten) - <code>protectedField</code> stays \"default\" (protected from null)</p> <p>This makes the behavior more consistent: if a field doesn't exist in MongoDB, the Java object is not modified.</p>"},{"location":"howtos/migration-v5-to-v6/#5-removed-deprecated-methods-from-morphium-class","title":"5. Removed Deprecated Methods from Morphium Class","text":"<p>Many deprecated methods were removed from the <code>Morphium</code> class in v6. Most update operations (set, unset, inc, push, pull, etc.) should now be performed through the <code>Query</code> class instead.</p>"},{"location":"howtos/migration-v5-to-v6/#update-operations-use-query-methods","title":"Update Operations: Use Query Methods","text":"<p>Removed methods (were deprecated in v5): - <code>morphium.set(entity, collection, values, upsert, callback)</code> - <code>morphium.unset(entity, collection, field, callback)</code> - <code>morphium.inc(fieldsToInc, query, upsert, multiple, callback)</code></p> <p>Migration:</p> <p>Old (v5): <pre><code>// Setting values on entities matching a query\nMap&lt;Enum, Object&gt; values = new HashMap&lt;&gt;();\nvalues.put(MyEntity.Fields.status, \"active\");\nmorphium.set(entity, null, values, false, null);\n\n// Unsetting a field\nmorphium.unset(entity, null, \"fieldName\", null);\n\n// Incrementing values\nMap&lt;Enum, Number&gt; increments = new HashMap&lt;&gt;();\nincrements.put(MyEntity.Fields.counter, 1);\nmorphium.inc(increments, query, false, true, null);\n</code></pre></p> <p>New (v6): <pre><code>// Use Query.set() instead\nQuery&lt;MyEntity&gt; query = morphium.createQueryFor(MyEntity.class);\nquery.f(\"_id\").eq(entity.getId());\nquery.set(\"status\", \"active\");\n\n// Use Query.unset() instead\nquery.unset(\"fieldName\");\n\n// Use Query.inc() instead\nquery.inc(MyEntity.Fields.counter, 1);\n</code></pre></p> <p>Note: The methods <code>setInEntity()</code> and <code>unsetInEntity()</code> still exist for updating specific entities directly.</p>"},{"location":"howtos/migration-v5-to-v6/#query-creation-unified-method","title":"Query Creation: Unified Method","text":"<p>Removed methods: - <code>createQueryFor(Class, String collectionName)</code> - two-parameter version removed - <code>createQueryByTemplate(T template, String... fields)</code> - template-based queries removed - <code>findByTemplate(T template, String... fields)</code> - template-based find removed</p> <p>Migration:</p> <p>Old (v5): <pre><code>// Creating query with custom collection name\nQuery&lt;MyEntity&gt; query = morphium.createQueryFor(MyEntity.class, \"custom_collection\");\n\n// Template-based queries\nMyEntity template = new MyEntity();\ntemplate.setStatus(\"active\");\nList&lt;MyEntity&gt; results = morphium.findByTemplate(template, \"status\");\n</code></pre></p> <p>New (v6): <pre><code>// Use single-parameter createQueryFor and specify collection on query\nQuery&lt;MyEntity&gt; query = morphium.createQueryFor(MyEntity.class);\nquery.setCollectionName(\"custom_collection\");\n\n// Template-based queries: use standard query syntax\nQuery&lt;MyEntity&gt; query = morphium.createQueryFor(MyEntity.class);\nquery.f(\"status\").eq(\"active\");\nList&lt;MyEntity&gt; results = query.asList();\n</code></pre></p>"},{"location":"howtos/migration-v5-to-v6/#other-removed-methods","title":"Other Removed Methods","text":"<p>Read operations: - <code>readAll(Class)</code> - removed (use <code>createQueryFor(Class).asList()</code>) - <code>findByField(Class, field, value)</code> - removed (use query with field filter) - <code>findById(Class, id, collection)</code> - three-parameter version removed</p> <p>Index operations: - <code>ensureIndex(Class, callback, Enum... fields)</code> - removed (use <code>ensureIndices(Class)</code>) - <code>getIndexesFromMongo(Class)</code> - removed (use driver-specific methods)</p> <p>Other operations: - <code>flush(Class)</code> - removed (use buffered writer methods directly) - <code>createAggregator(Class, resultClass)</code> - removed (use <code>aggregate()</code> on Query) - <code>mapReduce(Class, map, reduce)</code> - removed (MongoDB deprecated map-reduce in favor of aggregation)</p> <p>Migration approach: 1. Replace <code>morphium.set/unset/inc/push/pull</code> with equivalent <code>query.set/unset/inc/push/pull</code> methods 2. Use <code>Query</code> for all update operations instead of direct <code>Morphium</code> methods 3. Use standard query syntax instead of template-based queries 4. For simple operations like <code>findById</code>, use <code>query.f(Query.ID_FIELD).eq(id).get()</code></p>"},{"location":"howtos/migration-v5-to-v6/#6-inmemorydriver-improvements-v6","title":"6. InMemoryDriver Improvements (v6)","text":"<p>The InMemoryDriver received major enhancements in v6.0:</p>"},{"location":"howtos/migration-v5-to-v6/#change-streams","title":"Change Streams","text":"<ul> <li>Full change stream support with document snapshots</li> <li>Proper event isolation preventing dirty reads</li> <li>Database-scoped driver sharing with reference counting</li> <li>Multiple Morphium instances can share the same InMemoryDriver when using the same database name</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#message-queue-testing","title":"Message Queue Testing","text":"<pre><code>// Multiple messaging instances can now share InMemoryDriver correctly\nMorphiumMessaging msg1 = morphium1.createMessaging();\nMorphiumMessaging msg2 = morphium2.createMessaging();\n// Both will receive change stream events from the shared driver\n</code></pre>"},{"location":"howtos/migration-v5-to-v6/#known-limitations","title":"Known Limitations","text":"<ul> <li>No replica set simulation (single-instance only)</li> <li>No sharding support</li> <li>Limited geospatial operations compared to MongoDB</li> <li>See <code>docs/howtos/inmemory-driver.md</code> for detailed feature coverage</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#new-features-in-v6","title":"New Features in v6","text":""},{"location":"howtos/migration-v5-to-v6/#1-virtual-threads-support","title":"1. Virtual Threads Support","text":"<p>Morphium 6 uses Java 21 virtual threads for: - Change stream event dispatching - Async operation handling - Lightweight concurrent processing</p>"},{"location":"howtos/migration-v5-to-v6/#2-enhanced-configuration","title":"2. Enhanced Configuration","text":"<ul> <li>URI-based configuration: <code>MONGODB_URI</code> environment variable</li> <li>System properties: <code>-Dmorphium.driver=inmem</code></li> <li>Properties file: <code>morphium-test.properties</code></li> </ul>"},{"location":"howtos/migration-v5-to-v6/#3-test-infrastructure","title":"3. Test Infrastructure","text":"<ul> <li>Tag-based test organization (<code>@Tag(\"core\")</code>, <code>@Tag(\"messaging\")</code>, <code>@Tag(\"inmemory\")</code>)</li> <li>Improved test runner: <code>./runtests.sh</code> with retry logic and filtering</li> <li>Better isolation between tests with proper driver lifecycle management</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Update to Java 21+</li> <li>[ ] Update pom.xml dependency to <code>6.0.0</code> or higher</li> <li>[ ] Replace flat config setters with nested settings objects</li> <li>[ ] Change messaging instantiation to <code>morphium.createMessaging()</code></li> <li>[ ] Update messaging code: replace <code>getName()</code>/<code>setName()</code> with <code>getTopic()</code>/<code>setTopic()</code></li> <li>[ ] Replace removed <code>Morphium</code> methods:</li> <li>[ ] <code>morphium.set/unset/inc()</code> \u2192 use <code>query.set/unset/inc()</code> instead</li> <li>[ ] <code>morphium.findByTemplate()</code> \u2192 use standard query syntax</li> <li>[ ] <code>morphium.readAll()</code> \u2192 use <code>query.asList()</code></li> <li>[ ] <code>morphium.findByField()</code> \u2192 use query with field filter</li> <li>[ ] <code>morphium.createQueryFor(Class, collection)</code> \u2192 use <code>query.setCollectionName()</code></li> <li>[ ] Review null handling behavior: consider adding <code>@IgnoreNullFromDB</code> to fields that need protection from null values</li> <li>[ ] Remove deprecated <code>@UseIfnull</code> annotations (behavior is now inverted)</li> <li>[ ] Review custom driver/messaging implementations for annotation requirements</li> <li>[ ] Update test infrastructure to use tags if using parameterized tests</li> <li>[ ] Test with InMemoryDriver to verify change stream handling</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#jms-support","title":"JMS Support","text":"<ul> <li>The JMS classes provided are experimental/incomplete and should not be relied upon for full JMS compatibility</li> <li>May be completed in upcoming versions</li> </ul>"},{"location":"howtos/migration-v5-to-v6/#getting-help","title":"Getting Help","text":"<ul> <li>Check <code>docs/troubleshooting-guide.md</code> for common issues</li> <li>Review <code>docs/howtos/</code> for specific use cases</li> <li>Join our Slack: https://join.slack.com/t/team-morphium/shared_invite/...</li> </ul>"},{"location":"releases/","title":"Release Documentation","text":"<p>This directory contains detailed release notes for each Morphium version.</p>"},{"location":"releases/#documentation-structure","title":"Documentation Structure","text":"<p>Root Level: - <code>CHANGELOG.md</code> - Single changelog file with all releases (standard format, Keep a Changelog)</p> <p>This Directory (<code>docs/releases/</code>): - <code>CHANGELOG-X.Y.Z.md</code> - Comprehensive technical changelog with implementation details - <code>RELEASE-NOTES-X.Y.Z.md</code> - Quick summary and migration guide for users</p>"},{"location":"releases/#why-this-structure","title":"Why This Structure?","text":"<ul> <li>Single CHANGELOG.md: Industry standard, easy to browse all versions</li> <li>Detailed docs: Technical teams need deep dive documentation</li> <li>Quick notes: Users need fast migration info without technical details</li> <li>No clutter: Root directory stays clean with just one changelog file</li> </ul>"},{"location":"releases/#for-future-releases","title":"For Future Releases","text":"<p>When creating a new release:</p> <ol> <li>Add entry to root <code>CHANGELOG.md</code> (concise)</li> <li>Create <code>docs/releases/CHANGELOG-X.Y.Z.md</code> (detailed)</li> <li>Create <code>docs/releases/RELEASE-NOTES-X.Y.Z.md</code> (user-facing)</li> <li>Update this README with the new release</li> </ol>"},{"location":"releases/#available-releases","title":"Available Releases","text":""},{"location":"releases/#601-tbd","title":"6.0.1 - TBD","text":"<p>Bugfix release with enhanced null handling and connection stability - Detailed Changelog - Quick Release Notes</p> <p>Highlights: - Bidirectional @UseIfNull behavior (protection from null contamination) - Socket timeout retry logic - Annotation rename: @UseIfnull \u2192 @UseIfNull</p>"},{"location":"releases/CHANGELOG-6.0.1/","title":"Morphium 6.0.1 Release Notes","text":"<p>Release Date: TBD Version: 6.0.1</p>"},{"location":"releases/CHANGELOG-6.0.1/#overview","title":"Overview","text":"<p>This is a bugfix release for Morphium 6.0, focusing on improving null value handling, connection stability, and fixing annotation naming inconsistencies.</p>"},{"location":"releases/CHANGELOG-6.0.1/#breaking-changes","title":"Breaking Changes","text":""},{"location":"releases/CHANGELOG-6.0.1/#null-handling-behavior-change","title":"\u26a0\ufe0f Null Handling Behavior Change","text":"<p>The default null handling behavior has been inverted to match standard ORM conventions (Hibernate, JPA, etc.).</p> <p>Previous Behavior (v6.0.0 and earlier): - Null values were NOT stored in the database by default (fields omitted) - Null values from DB were ignored during deserialization - Required <code>@UseIfNull</code> annotation to accept/store null values</p> <p>New Behavior (v6.0.1 and later): - Null values ARE stored as explicit nulls in the database by default - Null values from DB are accepted and set during deserialization - New <code>@IgnoreNullFromDB</code> annotation to protect fields from nulls</p> <p>Migration Required:</p> <pre><code>// OLD (v6.0.0) - Fields protected from nulls by default\nprivate Integer counter = 42;  // Null not stored, default preserved\n\n@UseIfNull\nprivate Integer nullableField;  // Null stored and accepted\n\n// NEW (v6.0.1) - Fields accept nulls by default\nprivate Integer counter = 42;  // Null stored and accepted (loses default!)\n\n@IgnoreNullFromDB\nprivate Integer protectedField = 42;  // Protected from nulls (keeps default)\n</code></pre> <p>Action Required: 1. Review all entity fields - Fields that should preserve defaults need <code>@IgnoreNullFromDB</code> 2. Remove <code>@UseIfNull</code> - Annotation is deprecated; default behavior now matches its old purpose 3. Add <code>@IgnoreNullFromDB</code> to fields that need protection from null contamination 4. Test thoroughly - Behavior change affects all entities</p>"},{"location":"releases/CHANGELOG-6.0.1/#useifnull-deprecated","title":"\u26a0\ufe0f @UseIfNull Deprecated","text":"<p>The <code>@UseIfNull</code> annotation is deprecated and replaced with <code>@IgnoreNullFromDB</code> for clearer semantics.</p> <p>Why the change? - The old annotation name was confusing (inverse logic) - New name clearly expresses intent: \"ignore null values from the database\" - Aligns with standard ORM conventions where nulls are accepted by default</p> <p>Migration: <pre><code>// OLD - Confusing inverse logic\nprivate Integer field1;  // Protected from nulls\n@UseIfNull\nprivate Integer field2;  // Accepts nulls\n\n// NEW - Clear, intuitive semantics\nprivate Integer field1;  // Accepts nulls (standard ORM)\n@IgnoreNullFromDB\nprivate Integer field2;  // Protected from nulls\n</code></pre></p>"},{"location":"releases/CHANGELOG-6.0.1/#bug-fixes","title":"Bug Fixes","text":""},{"location":"releases/CHANGELOG-6.0.1/#connection-stability","title":"Connection Stability","text":"<p>Socket Timeout Handling Improvements (<code>SingleMongoConnection.java</code>) - Added automatic retry logic for socket timeout exceptions - Improved timeout detection in watch operations - Enhanced error handling to prevent premature connection closure - Connection now retries on <code>SocketTimeoutException</code> instead of failing immediately</p> <p>Impact: Significantly improved stability for long-running operations and change streams.</p>"},{"location":"releases/CHANGELOG-6.0.1/#null-value-handling","title":"Null Value Handling","text":"<p>\ud83c\udfaf Major Enhancement: New @IgnoreNullFromDB Annotation (<code>ObjectMapperImpl.java</code>)</p> <p>The new <code>@IgnoreNullFromDB</code> annotation provides bidirectional protection from null contamination during both serialization and deserialization.</p> <p>Key Improvements: - Default behavior now matches standard ORMs (Hibernate, JPA) - Clear separation: \"field missing\" vs \"field with null value\" - Special handling for <code>@Id</code> fields (never stored when null) - Comprehensive documentation with behavior matrix</p> <p>Detailed Behavior:</p> <p>Without @IgnoreNullFromDB (Default - Standard ORM Behavior):</p> <p>Serialization (Writing to DB): - Null values stored as explicit null in database</p> <p>Deserialization (Reading from DB): - Field missing from DB \u2192 default value preserved - Field present as null in DB \u2192 null accepted, field set to null</p> <p>With @IgnoreNullFromDB (Protected from Null Contamination):</p> <p>Serialization (Writing to DB): - Null values NOT stored (field omitted from document)</p> <p>Deserialization (Reading from DB): - Field missing from DB \u2192 default value preserved - Field present as null in DB \u2192 null ignored, default value preserved \u2728 NEW</p> <p>Special @Id Field Handling: - Fields annotated with <code>@Id</code> are NEVER stored when null - Allows MongoDB to auto-generate unique <code>_id</code> values - Prevents E11000 duplicate key errors</p> <p>Impact: - Standard behavior aligns with other ORMs - Optional protection from null contamination - Better data integrity for migrations and external edits</p> <p>Example: <pre><code>@Entity\npublic class MyEntity {\n    @Id\n    private MorphiumId id;  // Never stored when null (auto-generated)\n\n    private Integer counter = 42;  // Accepts nulls (standard ORM)\n\n    @IgnoreNullFromDB\n    private Integer protectedCounter = 99;  // Protected from nulls\n}\n\n// MongoDB document: { counter: null, protectedCounter: null }\n// After deserialization:\n// counter = null              (accepted null - standard)\n// protectedCounter = 99       (protected from null!)\n</code></pre></p>"},{"location":"releases/CHANGELOG-6.0.1/#multi-collection-messaging","title":"Multi-Collection Messaging","text":"<p>Fixed Handling for Multi-Collection Messaging (<code>MessageRejectedException.java</code>) - Improved error handling when rejecting messages - Fixed exclusive message lock release - Enhanced connection management in rejection handler</p>"},{"location":"releases/CHANGELOG-6.0.1/#bulk-operations","title":"Bulk Operations","text":"<p>Bulk Operations Now Return Proper Statistics - Fixed <code>MorphiumBulkContext.runBulk()</code> to return operation statistics instead of null/empty results - All three driver implementations now properly collect and aggregate operation counts:   - <code>InMemoryDriver</code> - Fixed inline bulk context implementation   - <code>SingleMongoConnectDriver</code> - Fixed inline bulk context implementation   - <code>PooledDriver</code> - Fixed inline bulk context implementation</p> <p>Returned Statistics: <pre><code>Map&lt;String, Object&gt; result = bulkContext.runBulk();\n// Returns:\n// {\n//   \"num_inserted\": &lt;count&gt;,\n//   \"num_matched\": &lt;count&gt;,\n//   \"num_modified\": &lt;count&gt;,\n//   \"num_deleted\": &lt;count&gt;,\n//   \"num_upserts\": &lt;count&gt;,\n//   \"upsertedIds\": [&lt;list of IDs&gt;]  // Only if upserts occurred\n// }\n</code></pre></p> <p>Impact: Applications can now track bulk operation results for monitoring, logging, and validation purposes.</p> <p>Test Coverage: Added comprehensive test <code>BulkOperationTest.bulkTestReturnCounts()</code> verifying all count returns.</p>"},{"location":"releases/CHANGELOG-6.0.1/#performance-improvements","title":"Performance Improvements","text":"<p>Collection Name Caching - Added caching mechanism for collection names to reduce reflection overhead - Improves performance for repeated entity operations</p>"},{"location":"releases/CHANGELOG-6.0.1/#improvements","title":"Improvements","text":""},{"location":"releases/CHANGELOG-6.0.1/#documentation","title":"Documentation","text":"<p>Enhanced Null Handling Documentation - Added comprehensive JavaDoc for <code>@IgnoreNullFromDB</code> with behavior matrix - Included detailed examples for common use cases - Documented distinction between \"field missing\" vs \"field with null value\" - Added migration guide from <code>@UseIfNull</code> to <code>@IgnoreNullFromDB</code> - Documented special <code>@Id</code> field handling</p> <p>General Documentation Fixes - Updated CHANGELOG.md with breaking changes - Updated detailed release notes - Fixed various documentation inconsistencies - Updated code comments for clarity</p>"},{"location":"releases/CHANGELOG-6.0.1/#test-coverage","title":"Test Coverage","text":"<p>Updated Test Suites:</p> <ol> <li>UseIfNullTest - Updated for new @IgnoreNullFromDB behavior</li> <li>Verifies serialization and deserialization correctness</li> <li>Tests default value preservation</li> <li>Validates null protection with @IgnoreNullFromDB</li> <li> <p>Tests standard null acceptance without annotation</p> </li> <li> <p>UseIfNullDistinctionTest - Bidirectional behavior verification</p> </li> <li>Tests distinction between field missing vs. field with null value</li> <li>Verifies protection from null contamination</li> <li>Validates bidirectional annotation behavior</li> <li>Tests mixed scenarios and edge cases</li> <li> <p>Includes comprehensive behavior matrix documentation</p> </li> <li> <p>ObjectMapperTest &amp; ObjectMapperImplTest - Updated for new null behavior</p> </li> <li>Updated 6 test assertions to expect null fields in serialized output</li> <li>Verifies null values are stored as explicit nulls by default</li> <li> <p>Tests pass with both inmem and pooled drivers</p> </li> <li> <p>DefaultValuesTest - Updated to remove deprecated @UseIfNull</p> </li> <li>Tests default value behavior without annotation</li> <li>Verifies default behavior accepts nulls</li> </ol>"},{"location":"releases/CHANGELOG-6.0.1/#technical-details","title":"Technical Details","text":""},{"location":"releases/CHANGELOG-6.0.1/#modified-files","title":"Modified Files","text":"<p>Core - Annotations: - <code>src/main/java/de/caluga/morphium/annotations/IgnoreNullFromDB.java</code> - NEW annotation with comprehensive documentation - <code>src/main/java/de/caluga/morphium/annotations/UseIfNull.java</code> - Deprecated with migration guide</p> <p>Core - Implementation: - <code>src/main/java/de/caluga/morphium/ObjectMapperImpl.java</code> - Updated null handling logic:   - Line 559-568: Serialization - omit nulls only for @IgnoreNullFromDB fields   - Line 560-563: Special @Id field handling - never store null IDs   - Line 1001-1013: Deserialization - accept nulls unless @IgnoreNullFromDB   - Uses <code>objectMap.containsKey()</code> to distinguish \"missing\" vs \"null\"</p> <p>Driver: - <code>src/main/java/de/caluga/morphium/driver/wire/SingleMongoConnection.java</code> - Timeout handling - <code>src/main/java/de/caluga/morphium/driver/inmem/InMemoryDriver.java</code> - Bulk operations return counts - <code>src/main/java/de/caluga/morphium/driver/wire/SingleMongoConnectDriver.java</code> - Bulk operations return counts - <code>src/main/java/de/caluga/morphium/driver/wire/PooledDriver.java</code> - Bulk operations return counts</p> <p>Messaging: - <code>src/main/java/de/caluga/morphium/messaging/Msg.java</code> - Removed @UseIfNull (now default behavior) - <code>src/main/java/de/caluga/morphium/messaging/MessageRejectedException.java</code> - Error handling</p> <p>Test Data Classes: - <code>src/test/java/de/caluga/test/mongo/suite/data/ComplexObject.java</code> - Removed @UseIfNull - <code>src/test/java/de/caluga/test/mongo/suite/data/UncachedObject.java</code> - Added @IgnoreNullFromDB to boolData</p> <p>Tests - Updated for new behavior: - <code>src/test/java/de/caluga/test/mongo/suite/base/UseIfNullTest.java</code> - Updated to test @IgnoreNullFromDB - <code>src/test/java/de/caluga/test/mongo/suite/base/UseIfNullDistinctionTest.java</code> - Updated field names and behavior - <code>src/test/java/de/caluga/test/mongo/suite/base/DefaultValuesTest.java</code> - Removed @UseIfNull - <code>src/test/java/de/caluga/test/mongo/suite/base/ObjectMapperTest.java</code> - Updated 3 test assertions - <code>src/test/java/de/caluga/test/mongo/suite/base/ObjectMapperImplTest.java</code> - Updated 3 test assertions - <code>src/test/java/de/caluga/test/mongo/suite/base/BulkOperationTest.java</code> - Added bulkTestReturnCounts() test</p> <p>Documentation: - <code>CHANGELOG.md</code> - Updated with breaking changes and migration guide - <code>docs/releases/CHANGELOG-6.0.1.md</code> - Comprehensive release notes</p>"},{"location":"releases/CHANGELOG-6.0.1/#compatibility","title":"Compatibility","text":"<p>Minimum Requirements: (unchanged from 6.0.0) - Java 21+ - MongoDB 4.0+</p> <p>Dependencies: No changes to external dependencies</p>"},{"location":"releases/CHANGELOG-6.0.1/#migration-guide","title":"Migration Guide","text":""},{"location":"releases/CHANGELOG-6.0.1/#upgrading-from-600-to-601","title":"Upgrading from 6.0.0 to 6.0.1","text":"<p>\u26a0\ufe0f CRITICAL: This release contains a breaking change in null handling behavior that affects ALL entities.</p>"},{"location":"releases/CHANGELOG-6.0.1/#step-1-understand-the-behavior-change","title":"Step 1: Understand the Behavior Change","text":"<p>Old Behavior (6.0.0): - Null values NOT stored by default (fields omitted) - <code>@UseIfNull</code> required to accept/store nulls</p> <p>New Behavior (6.0.1): - Null values ARE stored by default (standard ORM behavior) - <code>@IgnoreNullFromDB</code> required to protect from nulls</p>"},{"location":"releases/CHANGELOG-6.0.1/#step-2-review-all-entity-classes","title":"Step 2: Review All Entity Classes","text":"<pre><code># Find all entity classes\ngrep -r \"@Entity\" src/ --include=\"*.java\"\n\n# Review each entity for null handling requirements\n</code></pre> <p>For each entity field, decide: - Accept nulls (standard): No annotation needed (NEW default) - Protect from nulls: Add <code>@IgnoreNullFromDB</code></p>"},{"location":"releases/CHANGELOG-6.0.1/#step-3-update-annotations","title":"Step 3: Update Annotations","text":"<pre><code>// SCENARIO 1: Field currently has no annotation\n// OLD behavior: Protected from nulls\n// NEW behavior: Accepts nulls\nprivate Integer counter = 42;\n\n// ACTION: If you want OLD behavior, add @IgnoreNullFromDB:\n@IgnoreNullFromDB\nprivate Integer counter = 42;\n\n// ACTION: If NEW behavior is OK, no change needed\n\n\n// SCENARIO 2: Field currently has @UseIfNull\n@UseIfNull\nprivate Integer nullableField;\n\n// ACTION: Remove @UseIfNull (deprecated, now default behavior)\nprivate Integer nullableField;\n\n\n// SCENARIO 3: Field has default value you want to preserve\nprivate String status = \"PENDING\";\n\n// ACTION: Add @IgnoreNullFromDB to prevent null contamination:\n@IgnoreNullFromDB\nprivate String status = \"PENDING\";\n</code></pre>"},{"location":"releases/CHANGELOG-6.0.1/#step-4-update-imports","title":"Step 4: Update Imports","text":"<pre><code># Add import for new annotation where needed\nimport de.caluga.morphium.annotations.IgnoreNullFromDB;\n\n# Remove @UseIfNull usages\nfind src/ -type f -name \"*.java\" -exec sed -i '' '/@UseIfNull/d' {} +\n</code></pre>"},{"location":"releases/CHANGELOG-6.0.1/#step-5-test-thoroughly","title":"Step 5: Test Thoroughly","text":"<pre><code># Run full test suite\nmvn clean test\n\n# Pay special attention to:\n# - Tests that expect null values to be stored/retrieved\n# - Tests that expect default values to be preserved\n# - Tests involving data migrations or external DB modifications\n</code></pre>"},{"location":"releases/CHANGELOG-6.0.1/#step-6-update-database-if-needed","title":"Step 6: Update Database (If Needed)","text":"<p>If you have existing documents with fields that should NOT be null:</p> <pre><code>// MongoDB shell - Example: Remove null values\ndb.myCollection.updateMany(\n  { fieldName: null },\n  { $unset: { fieldName: \"\" } }\n);\n\n// Or set to default value\ndb.myCollection.updateMany(\n  { fieldName: null },\n  { $set: { fieldName: 42 } }\n);\n</code></pre>"},{"location":"releases/CHANGELOG-6.0.1/#common-migration-patterns","title":"Common Migration Patterns","text":"<p>Pattern 1: Fields with meaningful defaults <pre><code>// Add @IgnoreNullFromDB to preserve defaults\n@IgnoreNullFromDB\nprivate Integer retryCount = 0;\n\n@IgnoreNullFromDB\nprivate String status = \"PENDING\";\n\n@IgnoreNullFromDB\nprivate Boolean enabled = true;\n</code></pre></p> <p>Pattern 2: Optional fields that can be null <pre><code>// No annotation needed (now default behavior)\nprivate String optionalDescription;\nprivate Integer optionalValue;\nprivate Date optionalTimestamp;\n</code></pre></p> <p>Pattern 3: Fields used in sparse indexes <pre><code>// Add @IgnoreNullFromDB to keep fields out of DB when null\n@Index\n@IgnoreNullFromDB\nprivate String uniqueCode;  // Only indexed when present\n</code></pre></p>"},{"location":"releases/CHANGELOG-6.0.1/#validation-checklist","title":"Validation Checklist","text":"<ul> <li>[ ] All entity classes reviewed</li> <li>[ ] <code>@UseIfNull</code> annotations removed</li> <li>[ ] <code>@IgnoreNullFromDB</code> added where needed</li> <li>[ ] Imports updated</li> <li>[ ] Tests updated and passing</li> <li>[ ] Database migration plan created (if needed)</li> <li>[ ] Staging environment tested</li> <li>[ ] Documentation updated</li> </ul>"},{"location":"releases/CHANGELOG-6.0.1/#no-migration-needed-if","title":"No Migration Needed If:","text":"<ul> <li>Your application doesn't use Morphium entities (unlikely)</li> <li>You're starting a new project (use new behavior from start)</li> </ul>"},{"location":"releases/CHANGELOG-6.0.1/#known-issues","title":"Known Issues","text":"<p>None identified in this release.</p>"},{"location":"releases/CHANGELOG-6.0.1/#contributors","title":"Contributors","text":"<ul> <li>Stephan B\u00f6sebeck (@sboesebeck) - Core development and bug fixes</li> </ul>"},{"location":"releases/CHANGELOG-6.0.1/#links","title":"Links","text":"<ul> <li>Repository: https://github.com/sboesebeck/morphium</li> <li>Documentation: http://caluga.de</li> <li>Issues: https://github.com/sboesebeck/morphium/issues</li> </ul>"},{"location":"releases/CHANGELOG-6.0.1/#next-release","title":"Next Release","text":"<p>Features planned for 6.1.0: - Additional performance optimizations - Enhanced aggregation pipeline support - Improved transaction handling</p> <p>Full Changelog: https://github.com/sboesebeck/morphium/compare/v6.0.0...v6.0.1</p>"},{"location":"releases/RELEASE-NOTES-6.0.1/","title":"Morphium 6.0.1 - Release Summary","text":""},{"location":"releases/RELEASE-NOTES-6.0.1/#quick-summary","title":"Quick Summary","text":"<p>Bugfix release focusing on null value handling improvements, connection stability, and annotation naming consistency.</p>"},{"location":"releases/RELEASE-NOTES-6.0.1/#breaking-change","title":"\u26a0\ufe0f Breaking Change","text":"<p>@UseIfnull renamed to @UseIfNull</p> <p>All instances of <code>@UseIfnull</code> must be changed to <code>@UseIfNull</code>. This is a simple find-and-replace operation.</p>"},{"location":"releases/RELEASE-NOTES-6.0.1/#key-improvements","title":"Key Improvements","text":""},{"location":"releases/RELEASE-NOTES-6.0.1/#1-bidirectional-useifnull-behavior-major-enhancement","title":"1. \ud83c\udfaf Bidirectional @UseIfNull Behavior (Major Enhancement)","text":"<ul> <li>NEW: Annotation now protects fields during BOTH write AND read operations</li> <li>Fields WITHOUT <code>@UseIfNull</code> are protected from null contamination in the database</li> <li>Prevents unwanted nulls from data migrations, manual edits, or external systems</li> <li>Impact: Improved data integrity and more predictable behavior</li> </ul> <p>Example: <pre><code>private Integer counter = 42;  // Protected from nulls in DB!\n\n@UseIfNull\nprivate Integer nullable = 99;  // Accepts nulls from DB\n</code></pre></p>"},{"location":"releases/RELEASE-NOTES-6.0.1/#2-enhanced-connection-stability","title":"2. Enhanced Connection Stability","text":"<ul> <li>Socket timeout exceptions now trigger automatic retries instead of closing connections</li> <li>Better handling of long-running operations and change streams</li> <li>Improved error detection in watch operations</li> </ul>"},{"location":"releases/RELEASE-NOTES-6.0.1/#3-bug-fixes","title":"3. Bug Fixes","text":"<ul> <li>Multi-collection messaging error handling</li> <li>Collection name caching for improved performance</li> <li>Various documentation improvements</li> </ul>"},{"location":"releases/RELEASE-NOTES-6.0.1/#migration-steps","title":"Migration Steps","text":"<ol> <li> <p>Replace <code>@UseIfnull</code> with <code>@UseIfNull</code> in your code:    <pre><code>find src/ -type f -name \"*.java\" -exec sed -i 's/@UseIfnull/@UseIfNull/g' {} +\n</code></pre></p> </li> <li> <p>Update imports if needed:    <pre><code>import de.caluga.morphium.annotations.UseIfNull;  // correct\n</code></pre></p> </li> <li> <p>Rebuild and test:    <pre><code>mvn clean install\n</code></pre></p> </li> </ol>"},{"location":"releases/RELEASE-NOTES-6.0.1/#testing-recommendations","title":"Testing Recommendations","text":"<p>Important: The bidirectional behavior may affect existing code:</p> <pre><code>@Entity\npublic class TestEntity {\n    // Without @UseIfNull: NOW PROTECTED from null in DB\n    private Integer counter = 42;  // Missing in DB: stays 42\n                                   // null in DB: stays 42 (NEW!)\n\n    // With @UseIfNull: accepts nulls\n    @UseIfNull\n    private Integer nullable = 42;  // Missing in DB: stays 42\n                                    // null in DB: becomes null\n}\n</code></pre> <p>Action: If you have fields that should accept null from the database, add <code>@UseIfNull</code>.</p>"},{"location":"releases/RELEASE-NOTES-6.0.1/#dependencies","title":"Dependencies","text":"<ul> <li>No external dependency changes</li> <li>Requires Java 21+</li> <li>Supports MongoDB 4.0+</li> </ul>"},{"location":"releases/RELEASE-NOTES-6.0.1/#whats-next","title":"What's Next","text":"<p>Version 6.1.0 will focus on: - Performance optimizations - Enhanced aggregation support - Improved transaction handling</p> <p>For detailed information, see CHANGELOG-6.0.1.md</p>"}]}